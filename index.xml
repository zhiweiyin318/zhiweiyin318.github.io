<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zhiwei Yin&#39;s Blog</title>
    <link>https://zhiweiyin318.github.io/</link>
    <description>Recent content on Zhiwei Yin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 31 Jul 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://zhiweiyin318.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://zhiweiyin318.github.io/about/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/about/</guid>
      
        <description>&lt;p&gt;Hi,我是殷智伟。&lt;br /&gt;
这里主要自己的工作学习生活笔记。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-Image</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image/</guid>
      
        <description>

&lt;h1 id=&#34;mount-namespace&#34;&gt;mount namespace&lt;/h1&gt;

&lt;p&gt;“左耳朵耗子” 叔的一篇将docker的Namespace的文章，文章地址：&lt;a href=&#34;https://coolshell.cn/articles/17010.html&#34;&gt;https://coolshell.cn/articles/17010.html&lt;/a&gt; ,里面有个小程序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/mount.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

/* 定义一个给 clone 用的栈，栈大小1M */
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];
 
char* const container_args[] = {
    &amp;#34;/bin/bash&amp;#34;,
    NULL
};

int container_main(void* arg)
{
    printf(&amp;#34;Container [%5d] - inside the container!\n&amp;#34;, getpid());
    execv(container_args[0], container_args);
    printf(&amp;#34;Something&amp;#39;s wrong!\n&amp;#34;);
    return 1;
}
 
int main()
{
    printf(&amp;#34;Parent [%5d] - start a container!\n&amp;#34;, getpid());
    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf(&amp;#34;Parent - container stopped!\n&amp;#34;);
    return 0;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;clone创建一个新的子进程，启动mount namespace（CLONE_NEWNS标志），子进程启动/bin/bash程序，这个shell就运行在mount namespace的隔离环境里。&lt;br /&gt;
编译下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw test]# gcc -o container container.c 
[root@yzw test]# ./container 
Parent [19645] - start a container!
Container [    1] - inside the container!
[root@yzw test]# ls /tmp/
test&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;发现依然能看到很多宿主机的文件。为什么mount namespace开启后，容器里面和宿主机的文件完全一样呢？&lt;br /&gt;
因为mount namespace修改的是容器进程对文件系统“挂载点”的认知，只有在“挂载”操作之后才能起作用，之前新创建的容器会继承宿主机的挂载点。&lt;br /&gt;
我们在上面程序bash操作前重新以tmpfs内存盘的格式mount /tmp目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;int container_main(void* arg)
{
    printf(&amp;#34;Container [%5d] - inside the container!\n&amp;#34;, getpid());
    //如果机器根目录的挂载类型是shared，得重新挂载根目录
    //mount(&amp;#34;&amp;#34;,&amp;#34;/&amp;#34;,NULL,MS_PRIVATE,&amp;#34;&amp;#34;)
    mount(&amp;#34;none&amp;#34;,&amp;#34;/tmp&amp;#34;,&amp;#34;tmpfs&amp;#34;,0,&amp;#34;&amp;#34;)
    execv(container_args[0], container_args);
    printf(&amp;#34;Something&amp;#39;s wrong!\n&amp;#34;);
    return 1;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;编译执行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw test]# gcc -o container container.c 
[root@yzw test]# ./container 
Parent [19861] - start a container!
Container [    1] - inside the container!
[root@yzw test]# ls /tmp/
[root@yzw test]# 
[root@yzw test]# mount -l | grep tmpfs
...
none on /tmp type tmpfs (rw,relatime,seclabel)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在宿主机上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 按理说应该是看不见的，在虚拟机里还能看到，后面再调查哈为啥？？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;tmp目录下已经和宿主机的tmp目录内容不一致了。&lt;/p&gt;

&lt;p&gt;当新创一个容器时，在容器进程启动前重新挂载根目录，由于mount namespace的存在，这个目录对宿主机不可见，容器里面的文件系统就是一个隔离的环境了。&lt;/p&gt;

&lt;h2 id=&#34;issue&#34;&gt;issue&lt;/h2&gt;

&lt;p&gt;重新挂载/tmp目录的实验执行完成后，在宿主机上居然可以看到这个挂载信息。。这是怎么回事呢？实际上，大家自己装的虚拟机，或者云上的虚拟机的根目录，很多都是以share方式的挂载的。这时候，你在容器里做mount也会继承share方式。这样就会把容器内挂载传播到宿主机上。解决这个问题，你可以在重新挂载/tmp之前，在容器内先执行一句：mount(“”, “/“, NULL, MS_PRIVATE, “”) 这样，容器内的根目录就是private挂载的了。（没起作用?）&lt;/p&gt;

&lt;h1 id=&#34;chroot&#34;&gt;chroot&lt;/h1&gt;

&lt;p&gt;chroot可以改变进程的根目录到指定目录，把bash和ls程序以及运行需要的so文件拷贝过来:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw tmp]# mkdir -p test/{bin,lib64,lib}
[root@yzw tmp]# cd test/
[root@yzw test]# cp /bin/{bash,ls} bin/
[root@yzw test]# T=/tmp/test
[root@yzw test]# list=&amp;#34;$(ldd /bin/ls | egrep -o &amp;#39;/lib.*\.[0-9]&amp;#39;)&amp;#34;
[root@yzw test]# for i in $list; do cp -v &amp;#34;$i&amp;#34; &amp;#34;${T}${i}&amp;#34;;done
[root@yzw test]# list=&amp;#34;$(ldd /bin/bash | egrep -o &amp;#39;/lib.*\.[0-9]&amp;#39;)&amp;#34;
[root@yzw test]# for i in $list; do cp -v &amp;#34;$i&amp;#34; &amp;#34;${T}${i}&amp;#34;;done
[root@yzw tmp]# chroot /tmp/test /bin/bash
bash-4.2# ls /
bin  lib  lib64&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;bash进程的根目录被修改了，感知不到宿主机的目录，这种方式和mount namespace效果类似，mount namespace就是基于chroot改进而来的。&lt;/p&gt;

&lt;h1 id=&#34;镜像&#34;&gt;镜像&lt;/h1&gt;

&lt;p&gt;为了让容器的这个根目录真实，我们一般会把给根目录挂载一个完整的操作系统的文件系统，比如ubuntu的ISO。这样启动之后，我们ls根目录就是整个ubuntu的所有目录和文件了。这个挂载在容器根目录，用来为容器j进程提供隔离后执行环境的文件系统，就是容器镜像，还有关于专业的名称，rootfs（根文件系统）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
ededc6515049        busybox             &amp;#34;/bin/sh&amp;#34;           2 hours ago         Up 2 hours                              cranky_lichterman
[root@yzw ~]# docker exec -it ededc6515049 /bin/sh
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;进入容器执行的sh，ls程序，就是容器/bin目录下的程序，和宿主机上的sh，ls完全不一样。&lt;/p&gt;

&lt;p&gt;docker项目最核心的的原理就是为带创建的用户进程：&lt;br /&gt;
1. 启动namespace设置；&lt;br /&gt;
2. 设置指定的cgroup参数；&lt;br /&gt;
3. 切换进程的根目录；&lt;br /&gt;
docker 优先使用pivot_root系统调用，如果不支持才使用chroot。&lt;/p&gt;

&lt;p&gt;rootfs只是一个操作系统包含的文件，配置和目录，并不包括内核。linux操作系统中，内核和这些是分开的，开机时将内核加载到内存中。所有同一个宿主机上的容器公用同一个内核。如果容器应用要修改内核的配置啥的会影响这个宿主机的，这点不如虚机隔离性好。&lt;/p&gt;

&lt;p&gt;容器的一致性&lt;/p&gt;

&lt;p&gt;不管是本地，还是云端，还是任何一个机器，用户只要解压打包好的rootfs，这个应用就能跑起来。解决了PaaS打包的大问题。&lt;/p&gt;

&lt;p&gt;如果一个rootfs做好，另外一个应用像在这个上面进行修改，再发布，这样维护起来比较麻烦，不具备扩展性。docker公司引入了layer的概念，用户制作镜像的每一个步骤，都会生成一个layer，就是一个增量的rootfs。&lt;/p&gt;

&lt;p&gt;Docker 的storage driver除了支持AUFS外，还支持devicemapper，overlayer，btrfs等，现在Docker CE默认为overlayer2，如果后端是direct-LVM的话，会默认为devicemapper。通过docker info可以查询到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw ~]# docker info
Containers: 1
 Running: 1
 Paused: 0
 Stopped: 0
Images: 109
Server Version: 18.06.1-ce
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;aufs&#34;&gt;AUFS&lt;/h2&gt;

&lt;p&gt;联合文件系统（union file system） unionFS最主要的功能就是可以将多个不同位置的目录联合挂载在同一个目录下。AUFS全称Another UnionFS，后面又叫Alternative UnionFS，再后就又叫Advance UnionFS，只能在ubuntu和Debian上使用，因为没有被Linus合入linux主分干，下面例子在Ubuntu上跑的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/tmp# tree
.
├── A
│   ├── a
│   └── x
├── B
│   ├── b
│   └── x
└── C

3 directories, 4 files
root@yzw-vm:/tmp# cat A/x
a
root@yzw-vm:/tmp# cat B/x
b
root@yzw-vm:/tmp# mount -t aufs -o dirs=./A:./B none ./C
root@yzw-vm:/tmp# tree
.
├── A
│   ├── a
│   └── x
├── B
│   ├── b
│   └── x
└── C
    ├── a
    ├── b
    └── x
3 directories, 7 files
root@yzw-vm:/tmp# cat C/x
a
root@yzw-vm:/tmp# df -h
Filesystem      Size  Used Avail Use% Mounted on
...
none             59G   22G   34G  40% /tmp/C
root@yzw-vm:/tmp# echo &amp;#34;c&amp;#34; &amp;gt; C/x
root@yzw-vm:/tmp# cat C/x
c
root@yzw-vm:/tmp# cat A/x
c
root@yzw-vm:/tmp# cat B/x
b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;合并后的C目录，x只有一份，通过“写时复制策略实现镜像的共享和最小化磁盘开销。对C中的文件进行修改，A，B 中对应文件也会生效(相同文件存在覆盖除外)。&lt;/p&gt;

&lt;p&gt;AUFS工作在文件的层次上，也就是说AUFS对文件的操作需要将整个文件复制到读写层内，哪怕只是文件的一小部分被改变，也需要复制整个文件。这在一定成度上会影响容器的性能，尤其是当要复制的文件很大，文件在栈的下面几层或文件在目录中很深的位置时，对性能的影响会很显著。&lt;/p&gt;

&lt;p&gt;通过“写时复制（CoW）”策略实现镜像的共享和最小化磁盘开销。任何对于底层文件系统分层的更改都会被“向上拷贝”到文件系统的一个临时、工作、或高层的分层里面。这个可写的层然后可以被看做是一个“改动（diff）”，能将之应用到下层只读的层，而这些层很可能作为底层被很多容器的进程中共享。&lt;/p&gt;

&lt;p&gt;一个Docker中使用分层文件系统的好处就是，1000个运行着bash的ubuntu:latest容器的副本，会共享一个底层的镜像，而并不会产生1000个文件系统的副本（vfs是个例外，请参考下边vfs部分）。并且同样重要的是，对于aufs和overlay的实现，用来读取或执行共享库的共享内存也在所有运行的容器之间共享，大大的减少了通用库如&amp;rsquo;libc&amp;rsquo;的内存占用。&lt;/p&gt;

&lt;h3 id=&#34;issue-1&#34;&gt;issue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;目录联合挂载时，如果A和B目录里的x文件内容不一样，这时如何处理？&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;aufs是一层一层往上盖的，所以我给的例子里，A里面的x会覆盖B里面的x.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/tmp# mount -t aufs -o dirs=./B:./A none ./C
root@yzw-vm:/tmp# tree
.
├── A
│   ├── a
│   └── x
├── B
│   ├── b
│   └── x
└── C
    ├── a
    ├── b
    └── x

3 directories, 7 files
root@yzw-vm:/tmp# cat C/x
b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;没有内核所以rootfs会比较小，请问一般安装的linux系统内核文件在哪里存放呢？
首先，docker镜像比较小不只是因为没有内核，内核本身其实不大。大小的差异主要因为我们平常看见的虚拟机镜像实际上是整个磁盘的快照。其次，一般情况下，内核放下安装盘里，解压到磁盘上，加载到内存中。有兴趣可以读这里：&lt;a href=&#34;https://blog.csdn.net/gatieme/article/details/50914250&#34;&gt;https://blog.csdn.net/gatieme/article/details/50914250&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;devicemapper&#34;&gt;devicemapper&lt;/h2&gt;

&lt;p&gt;早期Docker在Debian，Ubuntu系统中默认使用AUFS，RedHat系统用devicemapper。devicemapper是红帽系主推的。&lt;/p&gt;

&lt;p&gt;devicemapper是基于块设备的，不是基于文件的。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。&lt;/p&gt;

&lt;h2 id=&#34;overlay2&#34;&gt;overlay2&lt;/h2&gt;

&lt;h3 id=&#34;overlay2是什么&#34;&gt;overlay2是什么&lt;/h3&gt;

&lt;p&gt;Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，将着两个layers联合挂载后就是一个做为文件系统合并视图的“合并（merged）”目录。镜像层和容器曾可以有相同的文件，这中情况下，upperdir中的文件覆盖lowerdir中的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/overlay_constructs.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。&lt;br /&gt;
Overlay2支持多个下层目录，最多128个，解决了Overlay的inode耗尽的问题，继承了Overlay很多优点，包括包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。&lt;/p&gt;

&lt;p&gt;Docker 配置使用overlay2：&lt;a href=&#34;https://docs.docker.com/storage/storagedriver/overlayfs-driver/#configure-docker-with-the-overlay-or-overlay2-storage-driver&#34;&gt;https://docs.docker.com/storage/storagedriver/overlayfs-driver/#configure-docker-with-the-overlay-or-overlay2-storage-driver&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;举个例子&#34;&gt;举个例子&lt;/h3&gt;

&lt;p&gt;看下ubuntu镜像由5层构成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:~# docker pull ubuntu:latest
latest: Pulling from library/ubuntu
124c757242f8: Pull complete 
9d866f8bde2a: Pull complete 
fa3f2f277e67: Pull complete 
398d32b153e8: Pull complete 
afde35469481: Pull complete 
Digest: sha256:de774a3145f7ca4f0bd144c7d4ffb2931e06634f11529653b23eba85aef8e378
Status: Downloaded newer image for ubuntu:latest

root@yzw-vm:~# docker image inspect ubuntu
[
...
       &amp;#34;GraphDriver&amp;#34;: {
            &amp;#34;Data&amp;#34;: {
                &amp;#34;LowerDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339/diff:/var/lib/docker/overlay2/b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438/diff:/var/lib/docker/overlay2/098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314/diff:/var/lib/docker/overlay2/a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/diff&amp;#34;,
                &amp;#34;MergedDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/merged&amp;#34;,
                &amp;#34;UpperDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/diff&amp;#34;,
                &amp;#34;WorkDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/work&amp;#34;
            },
            &amp;#34;Name&amp;#34;: &amp;#34;overlay2&amp;#34;
        },
        &amp;#34;RootFS&amp;#34;: {
            &amp;#34;Type&amp;#34;: &amp;#34;layers&amp;#34;,
            &amp;#34;Layers&amp;#34;: [
                &amp;#34;sha256:a30b835850bfd4c7e9495edf7085cedfad918219227c7157ff71e8afe2661f63&amp;#34;,
                &amp;#34;sha256:6267b420796f78004358a36a2dd7ea24640e0d2cd9bbfdba43bb0c140ce73567&amp;#34;,
                &amp;#34;sha256:f73b2816c52ac5f8c1f64a1b309b70ff4318d11adff253da4320eee4b3236373&amp;#34;,
                &amp;#34;sha256:6a061ee02432e1472146296de3f6dab653f57c109316fa178b40a5052e695e41&amp;#34;,
                &amp;#34;sha256:8d7ea83e3c626d5ef1e6a05de454c3fe8b7a567db96293cb094e71930dba387d&amp;#34;
            ]
        },
...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在/var/lib/docker/overylay2目录下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt
total 156
drwx------ 4 root root 4096 Sep 12 11:25 ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0
drwx------ 2 root root 4096 Sep 12 11:25 l
drwx------ 4 root root 4096 Sep 12 11:25 c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339
drwx------ 4 root root 4096 Sep 12 11:25 b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438
drwx------ 4 root root 4096 Sep 12 11:25 098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314
drwx------ 3 root root 4096 Sep 12 11:25 a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412
...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;l目录包含了很多软连接，使用短名称指向了其他层。短名称用于避免mount参数时达到页面大小的限制。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt l/
total 152
lrwxrwxrwx 1 root root 72 Sep 12 11:25 AKSNN53ER6ZYNOBNG66LKFO64B -&amp;gt; ../ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 INN4Q6OLITXODWESIJWDCOU7W5 -&amp;gt; ../c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 USMKDHE2W2PPV64EAYHRKEJQDX -&amp;gt; ../b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 JGVKVFIFNC4A2SCJW2MTBLPCJK -&amp;gt; ../098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 2XXDFCYHLGAYYD4NHPEYWAQRAN -&amp;gt; ../a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/diff&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;link文件里是l目录下这个目录的短名称，diff目录就是镜像内容，lower文件指出了该层的组成，由高层到低层；work目录？？？&lt;/p&gt;

&lt;p&gt;最底层目录只有diff目录和link文件。其他底层目录除了diff，link外还有lower文件和work目录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls 098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/
diff  link
root@yzw-vm:/var/lib/docker/overlay2# ls a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/diff/
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@yzw-vm:/var/lib/docker/overlay2# cat a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/link 
2XXDFCYHLGAYYD4NHPEYWAQRAN
root@yzw-vm:/var/lib/docker/overlay2# cat ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/lower 
l/INN4Q6OLITXODWESIJWDCOU7W5:l/USMKDHE2W2PPV64EAYHRKEJQDX:l/JGVKVFIFNC4A2SCJW2MTBLPCJK:l/2XXDFCYHLGAYYD4NHPEYWAQRAN&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;容器运行起来后多了2个目录，读写层和初始层：&lt;/p&gt;

&lt;p&gt;merged（挂载点）： 容器根目录。&lt;br /&gt;
/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged&lt;/p&gt;

&lt;p&gt;upperdir（容器层）：初始时这个读写层时空的。&lt;br /&gt;
/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/diff&lt;/p&gt;

&lt;p&gt;lowerdir（镜像层）：总共6层，除了image的5层外，多了一个init层。&lt;br /&gt;
/var/lib/docker/overlay2/l/LC4OCZQCW7HCEKLXMY4AIYBT7U&lt;br /&gt;
/var/lib/docker/overlay2/l/AKSNN53ER6ZYNOBNG66LKFO64B&lt;br /&gt;
/var/lib/docker/overlay2/l/INN4Q6OLITXODWESIJWDCOU7W5&lt;br /&gt;
/var/lib/docker/overlay2/l/USMKDHE2W2PPV64EAYHRKEJQDX&lt;br /&gt;
/var/lib/docker/overlay2/l/JGVKVFIFNC4A2SCJW2MTBLPCJK&lt;br /&gt;
/var/lib/docker/overlay2/l/2XXDFCYHLGAYYD4NHPEYWAQRAN&lt;/p&gt;

&lt;p&gt;workdir：是用来完成如copy-on_write的操作。&lt;br /&gt;
/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work&lt;/p&gt;

&lt;p&gt;init层，这个位于只读层和读写层之间，docker项目单独生成的一个内部层，专门用来存/etc/hosts，/etc/resolv.conf等信息，这些原本属于ubuntu镜像一部分，但是用户往往需要在启动容器时写入一些指定的值比如hostname，需要在可读性层对他们进行修改。  这些修改支队当前容器有效，在docker commit时，不会把这一层提交掉，只会提交读写层。&lt;/p&gt;

&lt;p&gt;/etc/hosts, /etc/resolv.conf和/etc/hostname，容器中的这三个文件不存在于镜像，而是存在于/var/lib/docker/containers/&lt;container_id&gt;，在启动容器的时候，通过mount的形式将这些文件挂载到容器内部。&lt;/p&gt;

&lt;p&gt;修改容器里面/etc/hostname的内容，会在/var/lib/docker/containers/xxx/hostname看到修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/ubuntu-image-layer.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;容器内部的所有修改都在可读写层，docker commit和push保存的也是这个可读写层。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# docker run -it -d ubuntu /bin/bash
13d8a0e5162bfa3e087d20eef15a3805136ba2c2d6413356078ada71886639d4
root@yzw-vm:/var/lib/docker/overlay2# df -h
Filesystem      Size  Used Avail Use% Mounted on
...
tmpfs           395M   28K  395M   1% /run/user/120
tmpfs           395M   28K  395M   1% /run/user/1000
tmpfs           395M     0  395M   0% /run/user/0
overlay          59G   22G   35G  38% /var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged
shm              64M     0   64M   0% /var/lib/docker/containers/13d8a0e5162bfa3e087d20eef15a3805136ba2c2d6413356078ada71886639d4/mounts/shm

root@yzw-vm:/var/lib/docker/overlay2# mount | grep overlay
overlay on /var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/LC4OCZQCW7HCEKLXMY4AIYBT7U:/var/lib/docker/overlay2/l/AKSNN53ER6ZYNOBNG66LKFO64B:/var/lib/docker/overlay2/l/INN4Q6OLITXODWESIJWDCOU7W5:/var/lib/docker/overlay2/l/USMKDHE2W2PPV64EAYHRKEJQDX:/var/lib/docker/overlay2/l/JGVKVFIFNC4A2SCJW2MTBLPCJK:/var/lib/docker/overlay2/l/2XXDFCYHLGAYYD4NHPEYWAQRAN,upperdir=/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/diff,workdir=/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在容器内部可以看到overlay和shm两个文件挂载到根目录和/dev/shm目录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@13d8a0e5162b:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay          59G   22G   35G  38% /
tmpfs            64M     0   64M   0% /dev
tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup
/dev/sda1        59G   22G   35G  38% /etc/hosts
shm              64M     0   64M   0% /dev/shm
tmpfs           2.0G     0  2.0G   0% /proc/acpi
tmpfs           2.0G     0  2.0G   0% /proc/scsi
tmpfs           2.0G     0  2.0G   0% /sys/firmware&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各个layer目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt
total 32
drwx------ 5 root root 4096 Sep 12 14:23 e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a
drwx------ 4 root root 4096 Sep 12 14:23 e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init
drwx------ 2 root root 4096 Sep 12 14:23 l
drwx------ 4 root root 4096 Sep 12 11:25 ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0
drwx------ 4 root root 4096 Sep 12 11:25 c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339
drwx------ 4 root root 4096 Sep 12 11:25 b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438
drwx------ 4 root root 4096 Sep 12 11:25 098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314
drwx------ 3 root root 4096 Sep 12 11:25 a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a
diff  link  lower  merged  work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/diff/
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged/
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work/
work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work/work/
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/link 
A4DRDBGDJJI2XIR7VGQ4T2WOFF
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/lower 
l/LC4OCZQCW7HCEKLXMY4AIYBT7U:l/AKSNN53ER6ZYNOBNG66LKFO64B:l/INN4Q6OLITXODWESIJWDCOU7W5:l/USMKDHE2W2PPV64EAYHRKEJQDX:l/JGVKVFIFNC4A2SCJW2MTBLPCJK:l/2XXDFCYHLGAYYD4NHPEYWAQRAN
root@yzw-vm:/var/lib/docker/overlay2# 
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/diff/
dev  etc
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/work/
work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/work/work/
root@yzw-vm:/var/lib/docker/overlay2# 
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/link 
LC4OCZQCW7HCEKLXMY4AIYBT7U
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/lower 
l/AKSNN53ER6ZYNOBNG66LKFO64B:l/INN4Q6OLITXODWESIJWDCOU7W5:l/USMKDHE2W2PPV64EAYHRKEJQDX:l/JGVKVFIFNC4A2SCJW2MTBLPCJK:l/2XXDFCYHLGAYYD4NHPEYWAQRAN
root@yzw-vm:/var/lib/docker/overlay2# &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;容器使用overlay读写&#34;&gt;容器使用overlay读写&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;读容器层不存在的文件：&lt;br /&gt;
从镜像层中读取，有小的性能损耗。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;读只存在于容器层的文件：&lt;br /&gt;
直接读取，不拷贝，无额外性能损耗。&lt;/li&gt;
&lt;li&gt;读同时存在于容器和镜像层的文件：&lt;br /&gt;
直接读取容器层文件，因为容器层隐藏了镜像层的同名文件。无额外性能损耗。&lt;/li&gt;
&lt;li&gt;写一个文件：
容器写一个已经存在的文件，容器层不存在这个文件，overlay会将整个文件拷贝到容器层进行修改，拷贝只发生在第一次写入文件时，后面就直接容器层写了。&lt;br /&gt;
OverlayFS只工作在两层中。这比AUFS要在多层镜像中查找时性能要好。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;删除文件和目录：&lt;br /&gt;
删除文件时，容器层会镜像层创建一个whiteout文件，而镜像层的文件并没有被删，whiteout文件会隐藏它。例如删除一个foo文件，容器层创建一个.wh.foo的文件，当这两层被联合挂载之后，foo文件就会被.wh.foo文件遮挡起来消失了。翻译成“白障”。
删除目录时，容器层会创建一个不透明目录，和whiteout文件隐藏镜像层文件类似。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重命名目录：&lt;br /&gt;
只有在源路径和目的路径都在顶层容器层时，才允许执行rename操作。否则，会返回EXDEV。因此，你的应用需要能够处理EXDEV，并且回滚操作，执行替代的“拷贝和删除”策略。&lt;strong&gt;（没理解）&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;

&lt;p&gt;引用: &lt;a href=&#34;https://arkingc.github.io/2017/05/05/docker-filesystem-overlay/&#34;&gt;https://arkingc.github.io/2017/05/05/docker-filesystem-overlay/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般来说，overlay/overlay2很快，几乎肯定比aufs和devicemapper快。在某些特定场景下，还可能比btrfs快。 此外，还有几点overlay/overlay2驱动性能相关的注意事项：&lt;/p&gt;

&lt;p&gt;页缓存：OverlayFS支持页缓存共享，意味着多个容器访问相同的文件能够共享一个单一的page cache entry。 使得overlay/overlay2驱动能高效使用内存，是PaaS以及其它高密度场景一个好的选择。&lt;/p&gt;

&lt;p&gt;copy_up：对镜像层大文件进行写操作时，copy-on-write会给写操作带来大量延迟。&lt;/p&gt;

&lt;p&gt;inode 限制：使用overlay会引起过度的inode消耗，消耗会随着主机上的镜像和容器的增加而增加。 拥有大量镜像的主机在大量容器启动和停止时可能会耗尽inodes。 不幸的是你只能在文件系统创建时指定inode数，因此你可能需要考虑将/var/lib/docker放在另一个独立的设备上， 或者在创建文件系统时手动修改inode值。而overlay2则没有这样的问题。&lt;/p&gt;

&lt;p&gt;RPM和Yum：OverlayFS仅实现了POSIX标准的一部分，某些操作还会违反POSIX标准，copy_up操作就是其中一个。&lt;/p&gt;

&lt;p&gt;下面是提升OverlayFS驱动性能的最佳实践。&lt;/p&gt;

&lt;p&gt;SSD：为了获得最佳性能，一个通常的想法是使用诸如SSD这类更快的存储设备；&lt;/p&gt;

&lt;p&gt;使用数据卷： 数据卷提供了最好的以及最可预见的性能。 因为绕过了存储驱动，因此不会存在瘦供给和copy-on-write带来的潜在性能开销。 因此，写操作较频繁的数据应该放在数据卷上。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python docker-client</title>
      <link>https://zhiweiyin318.github.io/post/python-docker-client/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/python-docker-client/</guid>
      
        <description>

&lt;p&gt;简单记录哈python的docker client的使用。&lt;br /&gt;
&amp;gt; 官方文档：&lt;br /&gt;
&amp;gt; &lt;a href=&#34;https://docker-py.readthedocs.io/en/stable/client.html&#34;&gt;https://docker-py.readthedocs.io/en/stable/client.html&lt;/a&gt;&lt;br /&gt;
&amp;gt; &lt;a href=&#34;https://docs.docker.com/develop/sdk/examples/&#34;&gt;https://docs.docker.com/develop/sdk/examples/&lt;/a&gt;&lt;br /&gt;
&amp;gt; demo地址：&lt;br /&gt;
&amp;gt; &lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/dockerclient&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/dockerclient&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ pip install docker&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;

&lt;h2 id=&#34;client-初始化&#34;&gt;client 初始化&lt;/h2&gt;

&lt;p&gt;需要先创建一个DockerClient类的对象，相当于本地的docker client端。有三种方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker

# 方式1 base_url 可以是socket或者tcp方式，还有version，timeout等参数
dc = docker.APIClient(base_url=&amp;#39;unix://var/run/docker.sock&amp;#39;,timeout=5)
# 方式2
docker_kwargs = docker.utils.kwargs_from_env()
dc = docker.APIClient(version=&amp;#39;auto&amp;#39;, **docker_kwargs)
# 方式3 这是上面2个的子集
dc = docker.from_env()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;client-的方法&#34;&gt;client 的方法&lt;/h2&gt;

&lt;p&gt;client对象的有一些方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;dc.configs
dc.containers
dc.images
dc.networks
dc.nodes
dc.plugins
dc.volumes
dc.services
dc.events
...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;运行-查询-停止-删除-一个容器&#34;&gt;运行，查询，停止，删除 一个容器&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import docker
&amp;gt;&amp;gt;&amp;gt; dc = docker.from_env()
&amp;gt;&amp;gt;&amp;gt; dc.containers.run(&amp;#34;busybox&amp;#34;,&amp;#39;echo hello world&amp;#39;)
&amp;#39;hello world\n&amp;#39;
&amp;gt;&amp;gt;&amp;gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.from_env()
container = dc.containers.run(&amp;#34;busybox&amp;#34;, name=&amp;#39;test&amp;#39;, command=&amp;#39;echo hello world&amp;#39;, detach=True, tty=True,
                                stdin_open=True)
print container.logs()
print &amp;#34;containers: {}&amp;#34;.format(dc.containers.list())
print &amp;#34;container {} status is {}&amp;#34;.format(container.name, container.status)
container.stop()
container.remove()
print &amp;#34;container {} status is {}&amp;#34;.format(container.name, container.status)
print &amp;#34;containers: {}&amp;#34;.format(dc.containers.list())&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;list-pull-image&#34;&gt;list/pull image&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.from_env()
for i in dc.images.list():
    print &amp;#34;image ID:{}, tag:{}&amp;#34;.format(i.short_id, i.tags)
    for t in i.tags:
        if t == &amp;#34;busybox:latest&amp;#34;:
            print &amp;#34;remove image {}&amp;#34;.format(t)
            dc.images.remove(&amp;#39;busybox:latest&amp;#39;)

# if no tag is specified all tags from the repo will be pulled.
image = dc.images.pull(&amp;#39;busybox:latest&amp;#39;)
print &amp;#34;pull busybox image, id:{},tag:{}&amp;#34;.format(image.short_id, image.tags)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;low-level-api&#34;&gt;Low-level API&lt;/h2&gt;

&lt;p&gt;The main object-orientated API is built on top of APIClient. Each method on APIClient maps one-to-one with a REST API endpoint, and returns the response that the API responds with.&lt;/p&gt;

&lt;p&gt;It’s possible to use APIClient directly. Some basic things (e.g. running a container) consist of several API calls and are complex to do with the low-level API, but it’s useful if you need extra flexibility and power.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.APIClient(base_url=&amp;#39;unix://var/run/docker.sock&amp;#39;)
    print dc.version()
dc.containers()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;等同于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.from_env()
dc.api.containers()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;输出结果是json结构的map&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[{u&amp;#39;Status&amp;#39;: u&amp;#39;Up Less than a second&amp;#39;, u&amp;#39;Created&amp;#39;: 1536673589, u&amp;#39;Image&amp;#39;: u&amp;#39;busybox&amp;#39;, u&amp;#39;Labels&amp;#39;: {}, u&amp;#39;NetworkSettings&amp;#39;: {u&amp;#39;Networks&amp;#39;: {u&amp;#39;bridge&amp;#39;: {u&amp;#39;NetworkID&amp;#39;: u&amp;#39;754e02dfae9aa61b96e78ca6dfa743f121177c2985cd3179641e8650032180b4&amp;#39;, u&amp;#39;MacAddress&amp;#39;: u&amp;#39;02:42:ac:11:00:03&amp;#39;, u&amp;#39;GlobalIPv6PrefixLen&amp;#39;: 0, u&amp;#39;Links&amp;#39;: None, u&amp;#39;GlobalIPv6Address&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;IPv6Gateway&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;DriverOpts&amp;#39;: None, u&amp;#39;IPAMConfig&amp;#39;: None, u&amp;#39;EndpointID&amp;#39;: u&amp;#39;06443f233bfac60c83c9835172c9d076a9df406bd84a350e1e713fd274caf5d3&amp;#39;, u&amp;#39;IPPrefixLen&amp;#39;: 16, u&amp;#39;IPAddress&amp;#39;: u&amp;#39;172.17.0.3&amp;#39;, u&amp;#39;Gateway&amp;#39;: u&amp;#39;172.17.0.1&amp;#39;, u&amp;#39;Aliases&amp;#39;: None}}}, u&amp;#39;HostConfig&amp;#39;: {u&amp;#39;NetworkMode&amp;#39;: u&amp;#39;default&amp;#39;}, u&amp;#39;ImageID&amp;#39;: u&amp;#39;sha256:e1ddd7948a1c31709a23cc5b7dfe96e55fc364f90e1cebcde0773a1b5a30dcda&amp;#39;, u&amp;#39;State&amp;#39;: u&amp;#39;running&amp;#39;, u&amp;#39;Command&amp;#39;: u&amp;#39;/bin/sh&amp;#39;, u&amp;#39;Names&amp;#39;: [u&amp;#39;/cranky_lichterman&amp;#39;], u&amp;#39;Mounts&amp;#39;: [], u&amp;#39;Id&amp;#39;: u&amp;#39;ededc6515049f2d13b8ee79df0729bf9f8f4d92940e6012c4f1e23ccc055c0f7&amp;#39;, u&amp;#39;Ports&amp;#39;: []}, {u&amp;#39;Status&amp;#39;: u&amp;#39;Up About a minute&amp;#39;, u&amp;#39;Created&amp;#39;: 1536673521, u&amp;#39;Image&amp;#39;: u&amp;#39;busybox&amp;#39;, u&amp;#39;Labels&amp;#39;: {}, u&amp;#39;NetworkSettings&amp;#39;: {u&amp;#39;Networks&amp;#39;: {u&amp;#39;bridge&amp;#39;: {u&amp;#39;NetworkID&amp;#39;: u&amp;#39;754e02dfae9aa61b96e78ca6dfa743f121177c2985cd3179641e8650032180b4&amp;#39;, u&amp;#39;MacAddress&amp;#39;: u&amp;#39;02:42:ac:11:00:02&amp;#39;, u&amp;#39;GlobalIPv6PrefixLen&amp;#39;: 0, u&amp;#39;Links&amp;#39;: None, u&amp;#39;GlobalIPv6Address&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;IPv6Gateway&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;DriverOpts&amp;#39;: None, u&amp;#39;IPAMConfig&amp;#39;: None, u&amp;#39;EndpointID&amp;#39;: u&amp;#39;2a3d90402db5b9c26583a5bb4bad5c4561fb263cd2858d0e01774ab7fa5cc336&amp;#39;, u&amp;#39;IPPrefixLen&amp;#39;: 16, u&amp;#39;IPAddress&amp;#39;: u&amp;#39;172.17.0.2&amp;#39;, u&amp;#39;Gateway&amp;#39;: u&amp;#39;172.17.0.1&amp;#39;, u&amp;#39;Aliases&amp;#39;: None}}}, u&amp;#39;HostConfig&amp;#39;: {u&amp;#39;NetworkMode&amp;#39;: u&amp;#39;default&amp;#39;}, u&amp;#39;ImageID&amp;#39;: u&amp;#39;sha256:e1ddd7948a1c31709a23cc5b7dfe96e55fc364f90e1cebcde0773a1b5a30dcda&amp;#39;, u&amp;#39;State&amp;#39;: u&amp;#39;running&amp;#39;, u&amp;#39;Command&amp;#39;: u&amp;#39;/bin/sh&amp;#39;, u&amp;#39;Names&amp;#39;: [u&amp;#39;/loving_wright&amp;#39;], u&amp;#39;Mounts&amp;#39;: [], u&amp;#39;Id&amp;#39;: u&amp;#39;6721f996af1e9d04237fef0a1cb3f50e9e564173e8ff25056cdc475e8a985de5&amp;#39;, u&amp;#39;Ports&amp;#39;: []}]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>OpenStack olso_config</title>
      <link>https://zhiweiyin318.github.io/post/olso_config/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/olso_config/</guid>
      
        <description>

&lt;h1 id=&#34;oslo&#34;&gt;oslo&lt;/h1&gt;

&lt;p&gt;oslo作为OpenStack的通用组件，在每一个项目中都有用到，oslo.config主要用于命令行和配置项解析。  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考:&lt;/strong&gt;&lt;br /&gt;
* &lt;a href=&#34;https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html&#34;&gt;https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://blog.csdn.net/zhangyifei216/article/details/50434980&#34;&gt;https://blog.csdn.net/zhangyifei216/article/details/50434980&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://blog.csdn.net/hobertony_7/article/details/79206297&#34;&gt;https://blog.csdn.net/hobertony_7/article/details/79206297&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://www.programcreek.com/python/example/106149/oslo_config.cfg.ConfigOpts&#34;&gt;https://www.programcreek.com/python/example/106149/oslo_config.cfg.ConfigOpts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;使用说明&#34;&gt;使用说明&lt;/h1&gt;

&lt;p&gt;demo的代码归档：&lt;br /&gt;
&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/oslo_config&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/oslo_config&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#!/usr/bin/env python

# reference:
# https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html
# https://blog.csdn.net/zhangyifei216/article/details/50434980
# https://blog.csdn.net/hobertony_7/article/details/79206297
# https://www.programcreek.com/python/example/106149/oslo_config.cfg.ConfigOpts


from oslo_config import cfg
from oslo_config import types
import sys

BASE_OS_DISTRO = [&amp;#39;centos&amp;#39;, &amp;#39;rhel&amp;#39;, &amp;#39;ubuntu&amp;#39;, &amp;#39;oraclelinux&amp;#39;, &amp;#39;debian&amp;#39;]
# 命令行参数定义
_CLI_OPTS = [
    cfg.StrOpt(&amp;#39;os&amp;#39;, short=&amp;#39;o&amp;#39;, default=&amp;#39;centos&amp;#39;,
               choices=BASE_OS_DISTRO,
               help=&amp;#39;The system OS &amp;#39;
                    &amp;#39;are &amp;#39; + &amp;#39;, &amp;#39;.join(BASE_OS_DISTRO)),
    cfg.IntOpt(&amp;#39;cpu&amp;#39;, short=&amp;#39;c&amp;#39;, default=1, min=1,
               help=&amp;#39;The number of CPU&amp;#39;)
]

#配置参数定义
_CFG_OPTS = [
    cfg.StrOpt(&amp;#34;host&amp;#34;, default=&amp;#34;0.0.0.0&amp;#34;,
               help=&amp;#34;the host ip addr&amp;#34;),
    cfg.Opt(&amp;#34;port&amp;#34;, default=5999,
            type=types.Integer(1000, 6000),
            help=&amp;#34;the port number&amp;#34;)
]

_DEBUG_OPTS = [
    cfg.BoolOpt(&amp;#34;debug&amp;#34;, default=False,
                help=&amp;#34;debug config True or False&amp;#34;)
]


def main():

    # 定义configOpts实例还可以通过  conf = cfg.ConfigOpts()
    conf = cfg.CONF
    
    # 注册 命令和配置项
    conf.register_cli_opts(_CLI_OPTS)
    conf.register_opts(_DEBUG_OPTS)

    # 配置分组定义
    # DEFAULT是一个默认组，默认情况下Opt定义的选项都是属于这个组的，cfg Module给配置选项提供了组的概念，不同的组配置选项是可以重复的。
    ip_group = cfg.OptGroup(name=&amp;#34;IP&amp;#34;, title=&amp;#34;ip cfg&amp;#34;)
    conf.register_group(ip_group)

    # 待分组的配置项
    conf.register_opts(_CFG_OPTS, ip_group)

    # 获取参数，默认配置也可以通过--config-file来指定
    conf(args=sys.argv[1:],
         default_config_files=[&amp;#39;test.conf&amp;#39;])

    print &amp;#34;System OS is &amp;#34;, conf.os
    print &amp;#34;The number of CPU is &amp;#34;, conf.cpu
    print &amp;#34;The debug: &amp;#34;, conf.debug
    print &amp;#34;Host IP: &amp;#34;, conf.IP.host
    print &amp;#34;Port number: &amp;#34;, conf.IP.port


if __name__ == &amp;#39;__main__&amp;#39;:
    main()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;配置文件定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[DEFAULT]
debug = true

[IP]
host = 8.8.8.8
port = 4555&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-Cgroups-Namespace</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-cgroups-namepspace/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-cgroups-namepspace/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;容器其实就是一种沙盒技术的，沙盒就像集装箱一样，把应用装起来，应用于应用之间，有了边界，互不干扰，而且方便被搬来搬去，这就是PaaS最理想的状态。&lt;/p&gt;

&lt;p&gt;程序在操作系统的表现就是进程，容器技术的核心功能就是通过约束和修改进程的动态表现，创造出一个“边界”。Linux操作系统中，Cgroups技术是用来制造约束的手段，Namespace技术是用来修改进程视图的主要方法。&lt;/p&gt;

&lt;h2 id=&#34;隔离技术-namespace&#34;&gt;隔离技术（Namespace）&lt;/h2&gt;

&lt;p&gt;举个例子：&lt;br /&gt;
运行busybox容器，执行/bin/sh，在跑个sleep。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ docker run -it busybox /bin/sh
/ #
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    7 root      0:00 ps
/ # 
/ # sleep 100 &amp;amp;
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    9 root      0:00 sleep 100
   10 root      0:00 ps
/ # &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;宿主机上的进程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw zhiweiyin]# ps auxf
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1122  0.3  1.7 729148 66444 ?        Ssl  08:14   0:10 /usr/bin/dockerd
root      1318  0.5  0.7 574660 30976 ?        Ssl  08:14   0:16  \_ docker-containerd --config /var/run/docker/containerd/containerd.toml
root      4511  0.0  0.0   7488  3156 ?        Sl   08:58   0:00      \_ docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby
root      4529  0.0  0.0   1252   264 pts/0    Ss   08:58   0:00          \_ /bin/sh
root      4671  0.0  0.0   1232     4 pts/0    S+   09:01   0:00              \_ sleep 100&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;容器里面sh的进程号是1，但是在宿主机上进程号是4529，且是docker-containerd-shim的子进程，sleep也是类似，这就是Namespace机制，容器里面屏蔽掉了其他进程和进程号。&lt;/p&gt;

&lt;p&gt;Linux上创建线程是用clone,返回一个PID号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;int pid = clone(main_function,stack_size,SIGCHID,NULL)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当我们加上CLONE_NEWPID参数后，新创建的这个进程就会“看到”是一个全新的进程空间，在这个进程空间里PID是1。但是在主机上仍然是另外的PID号。多次执行clone会创建多个PID Namespace出来，每个进程里面PID都为1，看不到真正的宿主机上的PID，也看不到其他PID Namespace里的情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; int pid = clone(main_function,stack_size,CLONE_NEWPID|SIGCHID,NULL)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mount Namespace 用于被隔离进程只看到当前Namespace里的挂载点信息。&lt;br /&gt;
 Network Namespace 用于被隔离进程只看到当前Namespace里面的网络设备和配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这就是Linux容器实现的原理。创建容器进程时，指定了这个进程所需要启动的一组Namespace参数，这样容器就只能“看”到当前容器Namespace所限定的资源、文件、设置、状态、或者配置了，对于宿主机和其他不相干的进程都看不到了。容器其实是一种特殊的进程而已。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;虚拟机-vs-容器&#34;&gt;虚拟机 vs. 容器&lt;/h2&gt;

&lt;p&gt;先看两张图：&lt;br /&gt;
&lt;img src=&#34;https://zhiweiyin318.github.io/images/VM-Docker.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;左边是虚拟机的工作原理，Hypervisor的软件通过硬件的虚拟化功能，模拟出了运行一个操作系统所以需要的各种硬件，然后在模拟的硬件上按照一个操作系统 Guest OS，软件进程跑在这个Guest OS里，也就只能看到这个OS里面的文件和目录，以及虚拟设备。所以虚拟机也能隔离作用，但是开销太大，太重了，一个最小的CentOS KVM虚机启动后差不多需要100-200M内存，所有对资源的使用都得经过序集合软件，又是一层损耗。&lt;/p&gt;

&lt;p&gt;右边是容器的工作原理，Docker的位置是个应用一个级别的，和宿主机上其他应用进程是相同级别的，由宿主机统一管理，只不过被隔离的进程，额外设置了Namespace参数，Docker扮演的角色是辅助和管理，和Hypervisor完全不同。容器相对于虚机机来说几乎无损耗，也无需单独的Guest OS。但是容器也有弊端，所有容器之间隔离的不彻底，所有容器共用操作系统内核，内核有很多资源是不能被Namespace化的，比如时间。虚机机里面就可以随便这套了。所有应用容器化后什么可以做什么不可以做是需要考虑的一个问题，特别是对系统调用的使用上。&lt;/p&gt;

&lt;h2 id=&#34;资源限制技术-cgroups&#34;&gt;资源限制技术 Cgroups&lt;/h2&gt;

&lt;p&gt;通过Namespace技术虽然实现了容器的资源隔离，但是这个进程还是在宿主机上跑的，和其他进程共享CPU和内存的，有可能把宿主机上的CPU和内存吃完，Cgroups就是用来对进程设置资源限制的主要功能。&lt;/p&gt;

&lt;p&gt;Linux Cgroups 全称 Linux Control Group，限制一个进程使用的资源上限，包括CPU，内存，磁盘，网络带宽等。还可以对进程进行优先级设置，审计，将进程挂起和恢复等操作。&lt;/p&gt;

&lt;p&gt;Cgroups 给用户暴露出来的操作接口是文件系统，在/sys/fs/cgroup路径下，包括了各种限制资源类。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw ~]# mount -t cgroup
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)
[root@yzw cgroup]# ll /sys/fs/cgroup/
total 0
drwxr-xr-x. 5 root root  0 Sep 10 22:48 blkio
lrwxrwxrwx. 1 root root 11 Sep 10 22:48 cpu -&amp;gt; cpu,cpuacct
lrwxrwxrwx. 1 root root 11 Sep 10 22:48 cpuacct -&amp;gt; cpu,cpuacct
drwxr-xr-x. 5 root root  0 Sep 10 22:48 cpu,cpuacct
drwxr-xr-x. 3 root root  0 Sep 10 22:48 cpuset
drwxr-xr-x. 5 root root  0 Sep 10 22:48 devices
drwxr-xr-x. 3 root root  0 Sep 10 22:48 freezer
drwxr-xr-x. 3 root root  0 Sep 10 22:48 hugetlb
drwxr-xr-x. 5 root root  0 Sep 10 22:48 memory
lrwxrwxrwx. 1 root root 16 Sep 10 22:48 net_cls -&amp;gt; net_cls,net_prio
drwxr-xr-x. 3 root root  0 Sep 10 22:48 net_cls,net_prio
lrwxrwxrwx. 1 root root 16 Sep 10 22:48 net_prio -&amp;gt; net_cls,net_prio
drwxr-xr-x. 3 root root  0 Sep 10 22:48 perf_event
drwxr-xr-x. 5 root root  0 Sep 10 22:48 pids
drwxr-xr-x. 5 root root  0 Sep 10 22:48 systemd&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;举个例子：&lt;br /&gt;
cfs_period和cfs_quota组合使用，限制进程在cfs_period的一段时间内，只能被分到总量为cfs_quota的CPU时间。&lt;br /&gt;
在/sys/fs/cgroup/cpu目录下创建container文件夹，系统自动创建了一堆资源限制文件。这个目录就成为一个“控制组”。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw cpu]# mkdir container
[root@yzw cpu]# ls container/
cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们后台执行个死循环,top发现CPU1被吃完了，container控制组quota没有限制，period是100ms（100000us）。&lt;br /&gt;
我们修改配置，quota写入20ms就是说100ms该控制组的进程只能使用20ms的CPU，这个进程只使用20%的CPU带宽，我们把限制的进程PID写入该控制组。&lt;br /&gt;
再次top发现CPU1的使用率降下来了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw cpu]# while :; do : ;done &amp;amp;
[1] 3592

[root@yzw cpu]# top
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st

[root@yzw container]# cat cpu.cfs_period_us 
100000
[root@yzw container]# cat cpu.cfs_quota_us 
-1

[root@yzw container]# echo 20000 &amp;gt; cpu.cfs_quota_us 
[root@yzw container]# echo 3592 &amp;gt; tasks 
[root@yzw container]# top
%Cpu1  : 17.4 us,  0.0 sy,  0.0 ni, 82.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Cgroups的设计比较简单粗暴，就是一个子系统目录加上一组资源限制文件的组合。Docker等容器项目来说就是在各个子系统下，为每个容器创建一个控制组（就是新建个目录），然后启动容器进程后，把容器进程的PID写入对应控制组的tasks文件中就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw docker]# docker run -it --cpu-period=100000 --cpu-quota=20000 centos:7 /bin/bash
[root@90c9fd20daf8 /]# 

[root@yzw ~]# cd /sys/fs/cgroup/cpu/docker/90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd/
[root@yzw 90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd]# cat cpu.cfs_quota_us 
20000
[root@yzw 90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd]# cat cpu.cfs_period_us 
100000
[root@yzw 90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd]# &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;容器就是一个启动了多个Namespace的应用进程，这个进程能够使用的资源量，通过Cgroups配置限制。
&lt;strong&gt;容器技术中一个非常重要的概念，容器是一个单进程模型。&lt;/strong&gt; 用户的应用进程就是容器里面PID=1的进程，其他后续创建的进程都是这个进程的子进程，意味着你没法运行两个不同的应用，除非找到一个公共的PID=1的程序来充当两个不同程序的父进程。好多人使用systemd或者superviord来充当容器的启动进程。 容器的设计希望容器和进程应用同生命周期，对后续编排很重要，如果容器是正常运行的，里面的应用挂了，处理起来就很麻烦。&lt;/p&gt;

&lt;h1 id=&#34;issue&#34;&gt;issue&lt;/h1&gt;

&lt;p&gt;跟Namespace一样，Cgroups也有缺陷，提起最多的就是/proc文件系统的问题。/proc存储的是内核运行状态的一系列特殊文件，用户可以访问这些文件查看当前运行的进程的状态，比如CPU使用情况，内存使用情况，这些是top的主要数据来源。但是/proc不了解Cgroups的存在，就是容器里面读取的CPU核数，内存状态其实是宿主机的，会带来很多困惑和风险。&lt;br /&gt;
lxcfs可以增强docker资源的可见性，可解决这个问题。做法是把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。kubernetes环境下，也能用，以ds 方式运行 lxcfs ，自动给容器注入争取的 proc 信息。&lt;/p&gt;

&lt;p&gt;/proc文件系统的问题我好像遇到过这个坑..当时在容器上运行的java应用，由于当时jvm参数没正确配置上，就用默认的，而容器设置的内存为4g，最后oom了，当时用命令查看容器的内存占用情况，竟然发现内存竟然有60多g。 那应该显示的是宿主机的内存了，jvm按照宿主机内存大小分配的默认内存应该大于4g 所以还没full gc 就oom了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-History</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-history/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-history/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;我是2017年误打误撞的掉进了云计算这个坑里，上来就是Docker，Mesos，Kubernetes，现在主要从事Kubernetes相关工作。这两年对云计算的学习都是碎片化的，没有系统的学习思考过，碰巧看到有人推荐极客时间专栏《深入剖析Kubernetes》，就花钱订阅了，现在出去吃顿饭稍微吃爽也得一两张毛爷爷，几十块的课程舍不得就说不过去，看看课程目录想着应该干货不多，但是看来前面几节内容，深深的被吸引了。作者张磊，在云计算这个坑里摸爬滚打了数年，把这个行当的发展娓娓道来，侃侃而谈，深入浅出的介绍了为啥Docker，Kubernetes突然火起来了，把Docker，Kubernetes的技术也通俗易懂的语言在讲，最主要的是系统的在讲，这个正是我知识体系缺少的。&lt;br /&gt;
这里就开始记录我学习的一些笔记。&lt;br /&gt;
课程地址：&lt;a href=&#34;https://time.geekbang.org/column/article/14254&#34;&gt;https://time.geekbang.org/column/article/14254&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;

&lt;p&gt;这些年的教育导致凡事学个啥都想着先找个定义，云计算的定义相信这些年随着时间和技术的变革，不停的在发生着变化，我试着找了找定义：&lt;/p&gt;

&lt;h2 id=&#34;云计算&#34;&gt;云计算&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;“云计算的本质是一种服务提供模型，通过这种模型可以随时、随地、按需地通过网络访问共享资源池的资源，这个资源池的内容包括计算资源、网络资源、存储资源等，这些资源能够被动态地分配和调整，在不同用户之间灵活的划分。凡是符合这些特征的IT服务都可以成为云计算服务。&lt;br /&gt;
——Security Guidance for Critical Areas of Focus In Cloud Computing V3.0”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NIST(U.S. National Institute of Standards and Technology)提出了一个定义云计算的标准“NIST Working Definition of Cloud Computing/NIST 800-145”，这个标准中提出云计算具备的五个基本要素：&lt;strong&gt;通过网络分发服务、自助服务、可衡量的服务、资源的灵活调度、资源池化&lt;/strong&gt;。另外，这个标准还提到，云计算按照服务类型可以分为 &lt;strong&gt;IaaS、PaaS、SaaS&lt;/strong&gt; 三类，按照部署模式分为 &lt;strong&gt;公有云、私有云、混合云和社区云&lt;/strong&gt; 四种。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/IaaS-PaaS-SaaS.PNG&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iaas-infrastructure-as-a-service&#34;&gt;IaaS (Infrastructure as a service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Infrastructure as a service (IaaS)  is a cloud computing offering in which a vendor provides users access to computing resources such as servers, storage and networking. Organizations use their own platforms and applications within a service provider’s infrastructure.&lt;br /&gt;
Examples: DigitalOcean, Linode, Rackspace, Amazon Web Services (AWS), Microsoft Azure, Google Compute Engine (GCE), 阿里云，腾讯云&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;IaaS 要解决什么问题？&lt;br /&gt;
1. 用户不用购买硬件设备了，直接按需购买资源就行了。&lt;br /&gt;
2. 用户可以按需扩容缩容自己所需要的资源。 (业务忙时多申请几个机子，业务不忙了少几个机子，反正时按资源收费的。)&lt;br /&gt;
3. 不用安排专人维护硬件设备了，也不会有什么机房断电，设备单点故障了影响业务。&lt;br /&gt;
4. 用起来让你感觉跟物理机没啥区别。&lt;/p&gt;

&lt;h3 id=&#34;paas-platform-as-a-service&#34;&gt;PaaS (Platform as a Service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Platform as a service (PaaS) is a cloud computing offering that provides users with a cloud environment in which they can develop, manage and deliver applications. In addition to storage and other computing resources, users are able to use a suite of prebuilt tools to develop, customize and test their own applications.&lt;br /&gt;
Examples: AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine, Apache Stratos, OpenShift&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PaaS 要解决什么问题？&lt;br /&gt;
云上有了资源（虚拟机）后，提供给用户一套开发，测试，打包，发布，管理和运维的平台，让你很方便的在IaaS上搞你的业务，不用care底层资源 。&lt;/p&gt;

&lt;h3 id=&#34;saas-software-as-a-service&#34;&gt;SaaS (Software as a Service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Software as a service (SaaS)  is a cloud computing offering that provides users with access to a vendor’s cloud-based software. Users do not install applications on their local devices. Instead, the applications reside on a remote cloud network accessed through the web or an API. Through the application, users can store and analyze data and collaborate on projects.&lt;br /&gt;
Examples: Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SaaS 要解决什么问题？&lt;br /&gt;
这个我也没接触过，理解就是所有软件都在云上了，你只要类似打开浏览器的东东就可以用各种软件，不用再安装了，你的数据啥的都在云上了。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考:&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/cloud/learn/iaas-paas-saas&#34;&gt;https://www.ibm.com/cloud/learn/iaas-paas-saas&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.computenext.com/blog/when-to-use-saas-paas-and-iaas/&#34;&gt;https://www.computenext.com/blog/when-to-use-saas-paas-and-iaas/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Platform_as_a_service&#34;&gt;https://en.wikipedia.org/wiki/Platform_as_a_service&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&#34;&gt;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;历史&#34;&gt;历史&lt;/h1&gt;

&lt;h2 id=&#34;docker-的出现&#34;&gt;Docker 的出现&lt;/h2&gt;

&lt;p&gt;2013年那会云计算不再时虚无缥缈的概念了，已经商业化比较成熟了，AWS如日中天，Openstack火的一塌糊涂，以Cloud Foundry为代表的开源PaaS项目度过了最艰难的的概念普及和用户教育阶段，吸引力一堆知名技术厂商的投入，开始了以开源PaaS为核心构建平台层服务能力的变革，PaaS的时代来临了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Cloud Foundry is an open source, multi cloud application platform as a service (PaaS) governed by the Cloud Foundry Foundation, a 501&amp;copy;(6) organization.The software was originally developed by VMware and then transferred to Pivotal Software, a joint venture by EMC, VMware and General Electric.&lt;br /&gt;
&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Cloud_Foundry&#34;&gt;https://en.wikipedia.org/wiki/Cloud_Foundry&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker公司那会还叫dotCloud也是PaaS热潮的中一个小公司，主打产品与主流的Cloud Foundry社区脱节，长期无人问津。&lt;br /&gt;
* 2013年3月，dotCloud公司推出自己的容器开源项目Docker。&lt;br /&gt;
* 2013年10月，dotCloud公司正式转换业务核心并将自身重新定名为Docker。到这时，Docker已经拥有超过200名贡献者，其中九成以上来自公司之外。Docker的下载量超过10万次，包括eBay在内的众多企业开始对其加以利用，相关社区也在全球范围内快速建立。短短几个月Cloud Foundry和其他PaaS社区还没来得及成为它的对手就已经出局了。  dotCloud公司改名为Docker公司。&lt;/p&gt;

&lt;h2 id=&#34;遇到和解决了什么问题&#34;&gt;遇到和解决了什么问题&lt;/h2&gt;

&lt;h3 id=&#34;cloud-foundry的paas解决了什么问题&#34;&gt;Cloud Foundry的PaaS解决了什么问题&lt;/h3&gt;

&lt;p&gt;当时大家租赁AWS或者Openstack的虚机机，还是像以前管理物理机那样，通过脚本或者手动的方式在虚拟机上部署应用。但是云上的资源环境和物理机还是不一致的，当时的云计算服务比的是谁能更好的模拟本地服务器环境，能带来更好的“云上”体验。&lt;/p&gt;

&lt;p&gt;PaaS的出现就是解决这个问题的一个最佳方案。举个例子，虚拟机建好后，运维人员只需在这些机子上部署一个Cloud Foundry项目，然后执行一条命令就可以把本地的应用部署到云上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cf push &amp;#34;我的应用&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Cloud Foundry这样的PaaS项目最核心的组件就是打包和分发机制。为每种语言都定义一种打包机制，push时相当于把可执行文件和启动脚本打包到一个压缩包里面，上传到云上的存储种，然后调度一个可用的虚机，这个虚机的agent下载应用启动运行。&lt;/p&gt;

&lt;p&gt;由于同一个虚机会运行不同的应用，Cloud Foundry调用系统的Cgroups和Namespace机制为每一个应用单独创建一个叫“沙盒”的隔离环境，在“沙盒”里启动这些应用进程，实现一个虚机里面同时运行不同的应用，互不干涉。沙盒也就是后来的容器。&lt;/p&gt;

&lt;h3 id=&#34;docker解决了什么问题&#34;&gt;Docker解决了什么问题&lt;/h3&gt;

&lt;p&gt;Docker发布后，技术上跟Cloud Foundry的沙盒没有啥本质区别，但是最大不同就是容器的镜像。&lt;/p&gt;

&lt;p&gt;问题出在Cloud Foundry的一键部署很方便，但是打包却比较麻烦，一旦用上PaaS，用户必须为每一种语言，框架，甚至版本维护一给打好的包，而这个打包过程，除了可执行文件和启动脚本外，需要修改好多配置才能跑起来，这个修改没有经验可用借鉴，全凭试错尝试。&lt;/p&gt;

&lt;p&gt;Docker 镜像恰巧解决了这个问题。这个镜像就是一个压缩包，直接由一整套完整的操作系统的文件和目录组成的，有应用所需要的完整的依赖环境，内容可用和测试环境完全一样，所有不需要任何配置和修改直接保证了本地环境和云端环境的高读一致。拿着这个压缩包，使用某种技术创建一个“沙盒”环境，在沙盒里面解压缩，运行程序就可以了。&lt;strong&gt;这就是Docker的精髓。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PaaS最核心的打包系统一下子无用武之地了，抓狂的打包过程消失了。&lt;/p&gt;

&lt;p&gt;提供一个下载好的操作系统文件和目录，制作一个压缩包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;docker build &amp;#34;镜像&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Docker创建一个“沙盒”，解压压缩包，运行自己的应用。这个沙盒也是通过Cgroups和Namespace技术来实现环境隔离的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;docker run &amp;#34;镜像&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;docker公司是怎么把docker搞火的&#34;&gt;Docker公司是怎么把Docker搞火的&lt;/h3&gt;

&lt;p&gt;Docker公司的重要战略是“坚持把开发者群体放在至高无上的位置”，所以一开始Docker的推广是以开发者为主导的，简单的UI，有趣的demo，无论是你懂不懂后端，很简单就可以发布自己的应用，PaaS的受益者和最终用户，肯定都是开发者。&lt;br /&gt;
Docker只是个开源项目的名称，dotCloud公司将自己的公司名字改为了Docker，鲸鱼的Logo也成为了商业商标。&lt;/p&gt;

&lt;h3 id=&#34;docker为啥发布swarm项目&#34;&gt;Docker为啥发布Swarm项目&lt;/h3&gt;

&lt;p&gt;Docker项目的出现，让PaaS的定义由之前的CLoud Foundry描述的那样变成了一个由Docker镜像为标准的全新的概念。&lt;/p&gt;

&lt;p&gt;Docker虽然解决了打包的问题，还不能叫做PaaS，因为PaaS的另一个重要功能是大规模部署。Docker在2014年的DockerCon上推出了自己的容器集群管理项目Swarm，预示着Docker公司想重新定义PaaS的愿望。&lt;/p&gt;

&lt;p&gt;Docker的快速崛起后，CoreOS公司快速将容器融入自己的PaaS解决方案中，是当时DOcker项目的第二重要力量，但是随着Docker公司战略和对Docker项目的定位的改变，Docker公司想提供更多平台层的能力，向PaaS项目发展。显然和CoreOS的核心产品和战略冲突，2014年底CoreOS退出Docker项目，发布了自己Rocket(rkt)容器。&lt;/p&gt;

&lt;p&gt;CoreOS是一系列开源项目的组合，包括Container Linux操作系统，Fleet作业调度工具，systemd进程管理，rkt容器。Swarm则是以一个完整的整体来对外管理集群，最大亮点是完全使用Docker项目的API来完成管理集群，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#单机Docker项目：
docker run “我的镜像”

#集群Docker项目：
docker run -H “Swarm集群IP” “我的镜像”&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;编排概念的出现&#34;&gt;编排概念的出现&lt;/h3&gt;

&lt;p&gt;Docker的崛起，2014-2015年催生了一个繁荣的Docker生态，Docker收购了Fig项目，后面改名为Compose项目。&lt;/p&gt;

&lt;p&gt;编排在云计算领域是指通过工具或者配置来完成一组虚拟机以及相关资源的定义，配置，创建，删除等工作。&lt;/p&gt;

&lt;p&gt;Fig项目首次提出了容器编排概念“Container Orchestration”。通过执行一条简单命令，将一个配置文件里面定义的不同的容器，按照他们的指定关联关系创建起来。&lt;/p&gt;

&lt;h3 id=&#34;mesos的转型&#34;&gt;Mesos的转型&lt;/h3&gt;

&lt;p&gt;Mesos昨晚Berkeley主导的大数据套件之一，是当时大数据最受欢迎的资源管理项目，跟Yarn项目杀的难舍难分。大数据项目关注的是计算密集型离线业务，对应用打包和集群扩容托管没啥强烈需求，Hadoop，Spark等项目到现在也没有在容器上投入更大赌注。&lt;/p&gt;

&lt;p&gt;Mesos的两层调度系统，天然可以支持PaaS业务，Mesos+Marathon项目很快成了Docker Swarm的有力竞争对手。Mesos拥有超大规模集群管理的经验，也有大规模生产环境在使用了，比如eBa，。Marathon提供了应用托管和负载均功能。Mesos公司提出了DC/OS的口号和产品，旨在使用户能够像管理一台机器一样管理一个万级别的物理集群，并且使用Docker容器在这个集群中自由部署应用。&lt;/p&gt;

&lt;h3 id=&#34;kubernetes的诞生&#34;&gt;Kubernetes的诞生&lt;/h3&gt;

&lt;p&gt;这个时候CoreOS完全被Docker压制，RedHat作为Docker项目早期重要贡献者也因为Docker公司的平台战略不满退出，OpenSift还勉强支撑，Mesos和Swarm是主要竞争对手。2014年6月Google发力，发布了Kubernetes项目，这个项目不仅挽救了CoreOS和RedHat，同时改变了整个容器市场的格局。&lt;/p&gt;

&lt;p&gt;2014-2015年，整个容器社区热闹非凡，大量围绕Docker项目的网络，存储，监控，CI/CD，UI项目纷纷出台，也涌现出了Rancher，Tutun开源和商业上都取得成功的创业公司。Docker公司发布了Compose，Swarm和Machine三件套，Docker公司想从开源成功走向商业成功。&lt;/p&gt;

&lt;p&gt;Google的容器项目也招架住Docker，Google本想提议关停自己容器项目，和Docker共同推出了一个中立的容器运行时库（container runtime）作为Docker项目的核心依赖。DOcker没有同意削弱自己地位的建议，推出了自己的容器运行时库Libcontainer。由于比较匆忙，代码可读性差，可维护不强，被社区长期诟病。&lt;/p&gt;

&lt;p&gt;2015年6月，各个玩家开始切割Docker项目的话语权，手段也很经典。由Docker牵头，CoreOS，Google，RedHat等公司宣布，Docker将LibContainer捐出，改名RunC项目，交由一个完全中立的基金会管理，然后以RunC为依据，共同指定一套容器和镜像的标准和规范。&lt;/p&gt;

&lt;p&gt;这套标准规范就是OCI （open Container Initiative）。提出将容器运行和镜像的实现从Dokcer项目完全剥离出来，一方面改善了Docker在这一块一家独大的现状，另一方面各个玩家可以不依赖Docker项目构建各自的平台能力。这是一群玩家根据各自利益干涉的一个妥协结果。Docker公司虽然时OCI的发起者和创始成员，但是很少在标准指定上扮演关键角色，也没有动力去推进这些所谓的标准，这就是为啥OCI组织效率持续低下的根本原因。&lt;/p&gt;

&lt;p&gt;Docker不担心OCI的威胁，是因为Docker项目的容器生态的事实标准，社区足够庞大。但是斗争转移到容器之上的平台层，即PaaS，Docker公司就没有多大优势了。这个领域Google和RedHat有着深厚的技术积累，CoreOS这样的创业公司也有像Etcd这样的开源基础设施项目，Docker只有一个Swarm。&lt;/p&gt;

&lt;p&gt;Google，RedHat等开源基础设施玩家，共同牵头发起了一个CNCF（Cloud Native Computing Foundation）的基金会。目的就是希望以Kubernetes项目为基础，建立一个由开源基础设施厂商主导的，按照独立基金会运行的平台级社区，对抗Docker公司为核心的容器商业生态。&lt;/p&gt;

&lt;p&gt;Kubernetes的竞争对手为Swarm和Mesos，Swarm擅长和Docker生态无缝集成，Mesos擅长大规模集群的调度和管理。Kubernetes另开辟径，将Borg和Omega系统的内部特性落到Kubernetes项目上，就是Pod，Sidecar等超前的功能和设计模式。这些都是Google公司在这个领域多年的经验积累沉淀。RedHat和Google达成联盟，为这个项目投入了很多贡献，保证了自己的影响力。&lt;/p&gt;

&lt;p&gt;Mesos的Apache社区比较封闭，虽然成熟，但是缺乏创新，Swarm虽然强调Docker Native，但是杀伤力不大。Kubernetes项目耳目一新的设计理念和号召力，构建出了一个与众不同的容器编排和管理生态，迅速崛起，Github社区各项指标一骑绝尘，Swarm远远被甩身后。&lt;/p&gt;

&lt;p&gt;CNCF社区添加了像Prometheus，Fluentd，CNI等一系列容器知名生态工具和项目，大量的公司和创业团队开始专门针对CNCF社区而非Docker公司制定推广策略。&lt;/p&gt;

&lt;p&gt;Docker为了应对竞争，2016年宣布放弃Swarm项目，将容器编排和集群管理功能内置到Docker项目中，虽然可以使得Docker项目的边界扩大到一个完整的PaaS项目范畴，但是增加了技术复杂度和维护难度。&lt;/p&gt;

&lt;p&gt;Kubernetes反其道行之，在社区推进“民主化”架构，从API到容器运行时的每一层，都为开发者提供可扩展的插件机制，鼓励通过代码方式介入到Kubernetes的每一个阶段。催生了大量基于Kubernetes API和扩展接口的二次创业工作，社区在2016年之后得到了空前的发展。不同于之前局限于打包发布的PaaS化路线，这一次是围绕Kubernetes项目为核心的百花争鸣。Docker公司不得不面对这次豪赌的失败，开始放弃开源社区，专注于自己的商业化转型。&lt;/p&gt;

&lt;p&gt;2017年开始，Docker公司将DOcker项目的容器运行时部分Containerd捐赠给了CNCF社区，标志着Docker项目完全升级为一个PaaS平台，Docker宣布将Docker项目改名为Moby，交给社区自行维护。&lt;/p&gt;

&lt;p&gt;2017年10月，Docker宣布在自己主打产品Docker企业版内置Kubernetes项目。&lt;/p&gt;

&lt;p&gt;2018年1月20日，RedHat收购CoreOS。&lt;/p&gt;

&lt;p&gt;2018年3月28日，Docker公司的CTO Solomon Hykes 宣布辞职。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;后面这段历史原作者将的酣畅淋漓，基本照搬过来的。大家自行体会这几年这个领域的风云变化和各大玩家的角逐。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器技术兴起源于PaaS技术的普及&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker项目通过“容器镜像”，解决了应用打包这个根本性难题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器本身没有价值，有价值的是“容器编排”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>golang rand生成随机数</title>
      <link>https://zhiweiyin318.github.io/post/golang-rand%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/golang-rand%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      
        <description>

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;math/rand package实现了伪随机数字生成器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;随机数字是通过Source生成的，rand.Seed会初始化默认全局的Source，如果不调用rand.Seed就会使用默认的Source。所生成的随机数字是固定顺序生成的，每次运行程序如果seed相同的话，生成随机数是相同的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;默认的Source是线程安全的，自己通过New生成的不是。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;参考： &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34;&gt;https://golang.org/pkg/math/rand/&lt;/a&gt;&lt;br /&gt;
Package rand implements pseudo-random number generators.&lt;/p&gt;

&lt;p&gt;Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;源码：&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.go.demo/tree/master/rand&#34;&gt;https://github.com/zhiweiyin318/yzw.go.demo/tree/master/rand&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;rand1 使用默认的Seed和Source，每次执行main，获取的随机数字都是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand1() {
	fmt.Println(&amp;#34;rand1 test ######## rand.xx ######## &amp;#34;)
	fmt.Println(&amp;#34;rand int : &amp;#34;, rand.Int(), rand.Int31())
	// random int in [0,100)
	fmt.Println(&amp;#34;random int in [0,100) : &amp;#34;, rand.Intn(100))
	// random int in [-50,50)
	fmt.Println(&amp;#34;random int in [-50,50) : &amp;#34;, rand.Intn(100)-50)
	fmt.Println(&amp;#34;rand float : &amp;#34;, rand.Float64())
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand2 每次配置相同的Seed，则生成的随机值都是相同的。下面循环5次的随机数字都是一样的，因为Seed重装了Source，都是从头开始生成随机数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand2() {
	fmt.Println(&amp;#34;rand2 test ######## generate the same random values using the same rand.Seed  ######## &amp;#34;)
	for i := 0; i &amp;lt; 5; i++ {
		rand.Seed(10)
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand3 配置不同的Seed，生成的随机值是不同的。但是同一个Seed在执行main后生成的值都是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand3(){
	fmt.Println(&amp;#34;rand2 test ######## generate the same random values using the different rand.Seed  ######## &amp;#34;)
	for i := 0; i &amp;lt; 5; i++ {
		rand.Seed((int64)(i))
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand4 使用rand.New()生成新的rand，rand.NewSource()生成新的Source。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand4() {
	fmt.Println(&amp;#34;rand4 test ######## rand.NewSource and rand.New ######## &amp;#34;)
	s := rand.New(rand.NewSource(1))
	for i := 0; i &amp;lt; 5; i++ {
		fmt.Println(&amp;#34;rand4: &amp;#34;, s.Int(), s.Intn(20), s.Float64())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand5 保证每次运行程序随机值跟上次不一样，可以通过当前实际生成Seed&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand5(){
	fmt.Println(&amp;#34;rand4 test ######## use time.Now().Unix() as seed ######## &amp;#34;)
	rand.Seed(time.Now().Unix())
	for i := 0; i &amp;lt; 5; i++ {
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand6 协程安全测试&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;待补充...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>golang的测试框架</title>
      <link>https://zhiweiyin318.github.io/post/golang%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/golang%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      
        <description>

&lt;h1 id=&#34;golang-测试框架&#34;&gt;golang 测试框架&lt;/h1&gt;

&lt;p&gt;本文主要介绍golang 测试的集中常见的框架。&lt;/p&gt;

&lt;h2 id=&#34;go-test&#34;&gt;go test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件名称位xx_test.go&lt;/li&gt;
&lt;li&gt;测试函数Testxxx(t *testing.T)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go test -v&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;goconvey&#34;&gt;GoConvey&lt;/h2&gt;

&lt;p&gt;可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性，集成go test。&lt;/p&gt;

&lt;p&gt;Write behavioral tests in your editor. Get live results in your browser.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/smartystreets/goconvey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;官网：&lt;code&gt;http://goconvey.co/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;介绍：&lt;code&gt;https://www.jianshu.com/p/e3b2b1194830&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/smartystreets/goconvey &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在$GOPATH/src目录下新增了github.com子目录，该子目录里包含了GoConvey框架的库代码&lt;/li&gt;
&lt;li&gt;在$GOPATH/bin目录下新增了GoConvey框架的可执行程序goconvey&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;web显示结果，在测试目录下执行goconvoy就可以&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;testing&amp;#34;
)

func Test_ServerRun(t *testing.T) {
    Convey(&amp;#34;Test ServerRun &amp;#34;, t, func() {
        Convey(&amp;#34;Case 1 port &amp;gt; 10000:&amp;#34;, func(){
            port := 100000
            So(ServerRun(port), ShouldBeError)
        })
        Convey(&amp;#34;Case 2 port &amp;lt;= 10000:&amp;#34;, func() {
            port := 1000
            So(ServerRun(port), ShouldBeNil)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;gostub&#34;&gt;GoStub&lt;/h2&gt;

&lt;p&gt;主要用来给全局变量打桩，也可以给函数打桩，无法给方法接口打桩。
* 项目：&lt;code&gt;https://github.com/prashantv/gostub&lt;/code&gt;
* 介绍：&lt;code&gt;https://www.jianshu.com/p/70a93a9ed186&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;安装-1&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/prashantv/gostub&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-1&#34;&gt;使用&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    &amp;#34;testing&amp;#34;
    . &amp;#34;github.com/prashantv/gostub&amp;#34;
)
func Test_ServerRun_Case3(t *testing.T){
    Convey(&amp;#34;Test ServerRun &amp;#34;,t,func(){
        Convey(&amp;#34;Case 1 IP is not local IP:&amp;#34;,func(){
            stubs :=Stub(&amp;amp;localIP,&amp;#34;192.168.1.1&amp;#34;)
            defer stubs.Reset()
            So(ServerRun(8080), ShouldBeError)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;monkey&#34;&gt;Monkey&lt;/h2&gt;

&lt;p&gt;可以给函数，方法打桩&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/bouk/monkey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;官网：&lt;code&gt;https://bou.ke/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;介绍：&lt;code&gt;https://www.jianshu.com/p/2f675d5e334e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装-2&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/bouk/monkey&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-2&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;inline 函数打桩无效&lt;/li&gt;
&lt;li&gt;方法的首字母大小写，只能给首大写字母的方法打桩&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    &amp;#34;github.com/bouk/monkey&amp;#34;
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;reflect&amp;#34;
    &amp;#34;testing&amp;#34;
    &amp;#34;errors&amp;#34;
)
func Test_ServerRun_Monkey(t *testing.T) {
    Convey(&amp;#34;Test ServerRun &amp;#34;, t, func() {
        Convey(&amp;#34;Case 1 Listen failed:&amp;#34;, func() {
            defer monkey.UnpatchAll()
            monkey.Patch(Listen, func(s *server) error {
                return errors.New(&amp;#34;fake return fail&amp;#34;)
            })
            So(ServerRun(8080), ShouldBeError)
        })

        Convey(&amp;#34;Case 2 s.GetIP failed:&amp;#34;, func() {
            var s *server
            defer monkey.UnpatchAll()
            monkey.PatchInstanceMethod(reflect.TypeOf(s), &amp;#34;GetIP&amp;#34;, func(_ *server) string {
                return &amp;#34;192.168.1.1&amp;#34;
            })
            So(ServerRun(8080),ShouldBeError)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;gomock&#34;&gt;GoMock&lt;/h2&gt;

&lt;p&gt;给接口打桩&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/golang/mock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文档：&lt;code&gt;https://godoc.org/github.com/golang/mock/gomock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参考：&lt;code&gt;https://www.jianshu.com/p/f4e773a1b11f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装-3&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;mkdir $GOPATH/src/golang.org/x/
cd $GOPATH/src/golang.org/x/
git clone https://github.com/golang/net.git net 
go install net
go get github.com/golang/mock/gomock
go install github.com/golang/mock/mockgen&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-3&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;生成接口的mock文件&lt;/li&gt;
&lt;li&gt;输出目录需要提起建好&lt;/li&gt;
&lt;li&gt;gomock的代码需放在$GOPATH/src下，mockgen运行时要在这个路径下访问gomock&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;./mockgen -source=/home/yzw/go/src/examples/pkg/common/common.go &amp;gt; /home/yzw/go/src/examples/test/common/mock_common.go&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    . &amp;#34;github.com/golang/mock/gomock&amp;#34;
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;testing&amp;#34;

    &amp;#34;examples/test/common&amp;#34;
    &amp;#34;errors&amp;#34;
    &amp;#34;github.com/bouk/monkey&amp;#34;
    &amp;#34;examples/pkg/common&amp;#34;
    &amp;#34;fmt&amp;#34;
)

func Test_ClientRun_GoMock(t *testing.T) {
    Convey(&amp;#34;Test ClientRun&amp;#34;, t, func() {
        ctrl := NewController(t)
        defer ctrl.Finish()
        mockOpter := mock_common.NewMockOpter(ctrl)
        mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))

        defer monkey.UnpatchAll()
        monkey.Patch(NewClient, func() common.Opter {
            fmt.Println(&amp;#34;fake newclient&amp;#34;)
            return mockOpter
        })
        So(ClientRun(&amp;#34;ip&amp;#34;,&amp;#34;port&amp;#34;,&amp;#34;opt&amp;#34;),ShouldBeError)
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果mock的接口被调用多次，需要用Times&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;)).Times(5)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;mock的接口有先后顺序的时候，需要同After，InOder来保序&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;getCall := mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))
mockOpter.EXPECT().Post(Any()).Return(errors.New(&amp;#34;mock post error&amp;#34;)).After(getCall)
InOder(
    mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))
    mockOpter.EXPECT().Post(Any()).Return(errors.New(&amp;#34;mock post error&amp;#34;))
)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://zhiweiyin318.github.io/post/hugo/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/hugo/</guid>
      
        <description>

&lt;h2 id=&#34;为啥搞blog&#34;&gt;为啥搞blog&lt;/h2&gt;

&lt;p&gt;之前在sina写过复盘日记，后来也没坚持下来；之前在github上用其他框架搭过blog，太繁琐了，也放弃了。&lt;/p&gt;

&lt;p&gt;最近在有道云上记笔记，开始用markdown，觉得很方便，正好看到Hugo这个go写的静态网页框架，天然对go的好感，索性就搞一把。&lt;/p&gt;

&lt;p&gt;以后把笔记就记这了，走哪都方便查看。&lt;/p&gt;

&lt;h2 id=&#34;怎么用hugo-github搭建blog&#34;&gt;怎么用hugo+github搭建blog&lt;/h2&gt;

&lt;h3 id=&#34;下载hugo可执行文件-二进制文件&#34;&gt;下载hugo可执行文件（二进制文件）&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;下载地址： &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;https://github.com/gohugoio/hugo/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;创建框架&#34;&gt;创建框架&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; ./hugo.exe new site blog     &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;下载更换主题&#34;&gt;下载更换主题&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cd blog
git clone https://github.com/xianmin/hugo-theme-jane.git themes/jane&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;主题下载地址：&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;修改主题&#34;&gt;修改主题&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; cp themes/jane/exampleSite/config.toml ./&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;特别是config.toml文件&lt;/p&gt;

&lt;h3 id=&#34;新建博文&#34;&gt;新建博文&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe new start.md&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;本地测试&#34;&gt;本地测试&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe server&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 可以查看效果&lt;/p&gt;

&lt;h3 id=&#34;发布&#34;&gt;发布&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;生成public文件夹，将该文件夹所有文件push到username.github.io仓库。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我之前以为要把整个目录上传，发现不现实，最后才搞明白是把public上传就可以了，但是每次生成发布比较麻烦，准备搞个脚本弄哈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;issue&#34;&gt;issue&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;怎么贴图&lt;br /&gt;
图片放到/static下，md里里面直接引用相对路径，比如我把图片放到static/images下了，直接引用/images/xxx就可以了。发布的时候会拷贝过去。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nanshu.wang/post/2015-01-31/&#34;&gt;http://nanshu.wang/post/2015-01-31/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&#34;&gt;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
  </channel>
</rss>