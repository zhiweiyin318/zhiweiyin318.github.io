<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zhiwei Yin&#39;s Blog</title>
    <link>https://zhiweiyin318.github.io/</link>
    <description>Recent content on Zhiwei Yin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 31 Jul 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://zhiweiyin318.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://zhiweiyin318.github.io/about/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/about/</guid>
      
        <description>&lt;p&gt;Hi,我是殷智伟。&lt;br /&gt;
这里主要自己的工作学习生活笔记。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>软件定义交付宣言</title>
      <link>https://zhiweiyin318.github.io/post/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E4%BA%A4%E4%BB%98%E5%AE%A3%E8%A8%80/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E4%BA%A4%E4%BB%98%E5%AE%A3%E8%A8%80/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;宣言原文地址：  &lt;a href=&#34;https://sdd-manifesto.org/?from=timeline&#34;&gt;https://sdd-manifesto.org/?from=timeline&lt;/a&gt;&lt;br /&gt;
宣言github地址: &lt;a href=&#34;https://github.com/sdd-manifesto/manifesto&#34;&gt;https://github.com/sdd-manifesto/manifesto&lt;/a&gt;&lt;br /&gt;
翻译：Zhiwei Yin&lt;br /&gt;
时间：2018-11-23&lt;br /&gt;
翻译github地址：&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.translation/tree/master/SDD_Manifesto&#34;&gt;https://github.com/zhiweiyin318/yzw.translation/tree/master/SDD_Manifesto&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;软件定义交付宣言&#34;&gt;软件定义交付宣言&lt;/h1&gt;

&lt;p&gt;我们认识到交付可用的软件改变着我们的世界。我们认识到代码是阐述精确活动的最佳方式。我们认识到代码只在我们交付的时候有用。&lt;/p&gt;

&lt;p&gt;交付是我们的工作，不是细节。现在是时候把核心技能应用到我们自己的工作中了。现在是时候“设计”我们的交付了。我们把工作划分为我们的和计算机的：我们来负责决策，计算机来负责自动化完成任务。&lt;/p&gt;

&lt;p&gt;交付工作本身就是唯一的。应用软件，组织，部署环境和团队的每次组合都有唯一的上下文。我们认识到每个团队都需要能理解这个唯一性的交付和自动化。我们认为自动化所有可重复的任务很重要，因为持续交付对满足业务需求是不可或缺的。&lt;/p&gt;

&lt;p&gt;我们用加速应用软件开发的方法来加速我们的自动化：使用现代架构和编程语言，以及通用功能的框架，库和服务。&lt;/p&gt;

&lt;p&gt;交付的基础设施现在是可编程的了，让我们对它编程吧。&lt;/p&gt;

&lt;h2 id=&#34;软件定义交付是&#34;&gt;软件定义交付是：&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;核心：&lt;/strong&gt;  交付对每个软件团队和组织来说是最基本的战略能力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一流的：&lt;/strong&gt; 交付的代码就是产品代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;战略的：&lt;/strong&gt; 在团队和组织层面做决策；并用代码轻松准确的实现它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续的：&lt;/strong&gt; 随着不断学习，我们持续改进我们的交付。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;设计：&lt;/strong&gt;&lt;br /&gt;
* &lt;strong&gt;现代软件架构：&lt;/strong&gt; 事件驱动和可扩展性。&lt;br /&gt;
* &lt;strong&gt;现代编程语言：&lt;/strong&gt; 逻辑最好在代码中展现，而不是图或者界面。脚本不要太多。&lt;br /&gt;
* &lt;strong&gt;基础模型：&lt;/strong&gt; 使用一种软件领域模型，使用可理解的代码。&lt;br /&gt;
* &lt;strong&gt;可测试：&lt;/strong&gt; 在产品发布前，确保在短时间内定位错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;合作：&lt;/strong&gt;&lt;br /&gt;
* &lt;strong&gt;开发者：&lt;/strong&gt; 每个人通过代码表达自己的专业技术，让所有人从中获益。&lt;br /&gt;
* &lt;strong&gt;软件：&lt;/strong&gt; 虽然我们都使用最好的工具，但是我们使用这些工具的方式是唯一的。&lt;br /&gt;
*  &lt;strong&gt;开发者和软件：&lt;/strong&gt; 协作的自动化方式可用提高我们的感知和实现我们的决策。它会把信息和执行的操作传递给我们，并让我们更好的理解自动化的行为。通过代码，我们可以区分团队共享的交付对象以及他们的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加速：&lt;/strong&gt;&lt;br /&gt;
* &lt;strong&gt;通过自动化：&lt;/strong&gt; 我们通过自动化执行重复的任务来加速我们的工作，并且规避错误。&lt;br /&gt;
* &lt;strong&gt;通过复用：&lt;/strong&gt; 开发人员，团队和组织之间共享通用的功能模块。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监控：&lt;/strong&gt;  用来监控和解决在生产环境交付环节出现问题的通用手段。&lt;br /&gt;
* &lt;strong&gt;追踪：&lt;/strong&gt; 在系统中的监控活动，和追踪这些活动的关系。&lt;br /&gt;
* &lt;strong&gt;调试：&lt;/strong&gt; 交互，检查和交付流程。&lt;br /&gt;
* &lt;strong&gt;度量：&lt;/strong&gt; 从整个交付流程中获取活动的度量数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;  (按照姓的首字母排序): Kenny Bastani, Marc Holmes, Rod Johnson, Jessica Kerr, Mik Kersten, Russ Miles, Erin Schnabel, Matt Stine. With the help and refinement of many members in the community.&lt;/p&gt;

&lt;p&gt;© 2018, the above authors, this declaration may be freely copied in any form, but only in its entirety through this notice.&lt;/p&gt;

&lt;p&gt;翻译中出现的一切问题都以原文为准。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>kolla源码走读</title>
      <link>https://zhiweiyin318.github.io/post/kolla%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/kolla%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;代码路径：&lt;a href=&#34;https://github.com/openstack/kolla&#34;&gt;https://github.com/openstack/kolla&lt;/a&gt;&lt;br /&gt;
代码版本: origin/stable/pike branch&lt;br /&gt;
文档: &lt;a href=&#34;https://docs.openstack.org/kolla/latest/&#34;&gt;https://docs.openstack.org/kolla/latest/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;kolla项目主要是把容器化的openstack的各个组件的容器编译出来的，实现很简单：&lt;br /&gt;
1. 定义Dockerfile.j2模板&lt;br /&gt;
2. 通过jinja2根据参数渲染模板生成Dockerfile&lt;br /&gt;
3. 调用docker的python接口build镜像&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;kolla 项目的难点不在项目的实现上，在各个组件编译的依赖上，rpm，pip安装相关组件的依赖上。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;项目目录结构&#34;&gt;项目目录结构&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw kolla]# tree -L 2
.
├── bindep.txt
├── contrib
├── doc
├── docker
│...
│   ├── base
│   │   ├── aarch64-cbs.repo
│   │   ├── ...
│   │   ├── Dockerfile.j2
│...
├── etc
│   ├── kolla
│   │   └── kolla-build.conf
│   └── oslo-config-generator
├── HACKING.rst
├── kolla
│   ├── cmd
│   ├── common
│   ├── exception.py
│   ├── exception.pyc
│   ├── hacking
│   ├── image
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── opts.py
│   ├── opts.pyc
│   ├── template
│   ├── tests
│   ├── version.py
│   └── version.pyc
├── kolla.egg-info
├── LICENSE
├── README.rst
├── releasenotes
├── requirements.txt
├── setup.cfg
├── setup.py
├── specs
├── test-requirements.txt
├── tests
├── tools
│   ├── build.py -&amp;gt; ../kolla/cmd/build.py
│   ├── cleanup-images
└── tox.ini&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;主要目录介绍：&lt;br /&gt;
* docker目录&lt;/p&gt;

&lt;p&gt;容器目录，包含了所有容器的Dockerfile模板Dockerfile.j2文件，和其他需要打包的一堆文件。&lt;/p&gt;

&lt;p&gt;base目录是所有基础容器镜像目录，其他容器都是From这个镜像的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kolla目录&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;放的源码，后面详细说。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tools目录&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些工具，最主要的就是*build.py&lt;em&gt;，是&lt;/em&gt;/kolla/cmd/build.py*的软链接，就是项目命令行工具的入口。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;etc目录&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;放的是配置文件kolla-build.conf，项目所有配置项都在里面，有一部分是跟命令行重合的，如果命令行配置了，就覆盖掉配置文件的配置了。&lt;/p&gt;

&lt;h1 id=&#34;源码&#34;&gt;源码&lt;/h1&gt;

&lt;h2 id=&#34;源码目录&#34;&gt;源码目录&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw kolla]# tree -L 3
.
├── cmd
│   ├── build.py
├── common
│   ├── config.py
│   ├── task.py
├── exception.py
├── hacking
├── image
│   ├── build.py
├── opts.py
├── template
│   ├── filters.py
│   ├── filters.pyc
│   ├── methods.py
│   └── methods.pyc
├── tests
├── version.py
└── version.pyc&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;目录介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cmd&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;build.py是命令行入口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;common&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;config.py是命令行和配置文件相关的定义和设置。所有参数都在这定义的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;image&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;build.py是build镜像的相关的流程。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;template&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给模板渲染时增加过滤和函数（属于jinja2的机制），替换字符串之类的操作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tests&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ut相关的东西。&lt;/p&gt;

&lt;h2 id=&#34;用到的主要库&#34;&gt;用到的主要库&lt;/h2&gt;

&lt;h3 id=&#34;oslo-config&#34;&gt;oslo_config&lt;/h3&gt;

&lt;p&gt;oslo作为OpenStack的通用组件，在每一个项目中都有用到，oslo.config主要用于命令行和配置项解析。&lt;/p&gt;

&lt;p&gt;写了一个简单的使用介绍和domo，放到了github上：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍：&lt;br /&gt;
&lt;a href=&#34;https://zhiweiyin318.github.io/post/olso_config/&#34;&gt;https://zhiweiyin318.github.io/post/olso_config/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;demo:&lt;br /&gt;
&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/oslo_config&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/oslo_config&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;jinja2&#34;&gt;jinja2&lt;/h3&gt;

&lt;p&gt;python的模板引擎，也是Flask的模板引擎，能根据模板字符串替换，有自己的语法规则。就是定义自己的模板，然后根据配置生成想要的内容。&lt;/p&gt;

&lt;p&gt;写的简单的使用介绍和domo，放到了github上：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍：&lt;br /&gt;
&lt;a href=&#34;https://zhiweiyin318.github.io/post/python-jinja2/&#34;&gt;https://zhiweiyin318.github.io/post/python-jinja2/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;demo：&lt;br /&gt;
&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/jinja2&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/jinja2&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dokcer-client&#34;&gt;dokcer-client&lt;/h3&gt;

&lt;p&gt;python的docker client的库，直接调用跟命令行一样使用docker。&lt;/p&gt;

&lt;p&gt;写的简单的使用介绍和domo，放到了github上：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍:&lt;br /&gt;
&lt;a href=&#34;https://zhiweiyin318.github.io/post/python-docker-client/&#34;&gt;https://zhiweiyin318.github.io/post/python-docker-client/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;demo:&lt;br /&gt;
&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/dockerclient&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/dockerclient&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码流程&#34;&gt;代码流程&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cmd/build.py main()  ## 入口
  -&amp;gt; image/build.py build.run_build()
    -&amp;gt; common/config.py common_config.parse(...) ## 命令行，配置文件参数的定义配置注册。
    -&amp;gt; KollaWorker()  ## build的任务对象,把命令行，配置文件的参数拿出来给对象。
      -&amp;gt; docker.APIClient() ## 创建docker api client 用于调用docker 接口
    -&amp;gt; kolla.setup_working_dir() ## 新建个放dockerfile和构建的工作目录，把docker目录的文件拷贝过来
    -&amp;gt; kolla.find_dockerfiles() ## 检查下工作目录下的dokerfile.j2文件
    -&amp;gt; kolla.create_dockerfiles() ## 做镜像文件
      -&amp;gt; jinja2.Environment() ## jinja2的使用流程 见jinja2 介绍
      -&amp;gt; jinja2.FileSystemLoader() 
      -&amp;gt; template.render() ## 所有的*j2模板重新渲染，后面写入新建dockerfie文件
    -&amp;gt; kolla.build_queue() ## 创建多队列来执行build操作
     -&amp;gt; queue.put(BuildTask(self.conf, image, push_queue))
    
      -&amp;gt; task.run()       
        -&amp;gt; BuildTask.run
          -&amp;gt; self.builder()
            -&amp;gt; self.dc.build  ## 调用 docker api 创建image
        
            -&amp;gt; PushTask.run
              -&amp;gt; self.push_image(image)
                -&amp;gt; self.dc.push  ## 调用 docker api push image到仓库
    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-Kubernetes</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-kubernetes/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-kubernetes/</guid>
      
        <description>

&lt;h1 id=&#34;容器的本质&#34;&gt;容器的本质&lt;/h1&gt;

&lt;p&gt;容器实际上是一个Linux Namespace、Linux Cgroups和rootfs三种技术构造出来的进程的隔离环境。&lt;br /&gt;
1. 容器的静态试图：一组联合挂载在/var/lib/docker/&amp;hellip;上的rootfs，即“容器镜像”Container Image。&lt;br /&gt;
2. 容器的动态试图：一个由Namespace和Cgroup构成的隔离环境，即“容器运行时”Container Runtime。&lt;/p&gt;

&lt;p&gt;作为一个开发者，不关心运行时，容器镜像才是真正承载容器信息进程传递的。容器编排由此出现，容器走向容器云。&lt;/p&gt;

&lt;h1 id=&#34;kubernetes的本质&#34;&gt;Kubernetes的本质&lt;/h1&gt;

&lt;h2 id=&#34;kubernetes-架构&#34;&gt;kubernetes 架构&lt;/h2&gt;

&lt;p&gt;Kubernetes项目的理论基础要比工程实践走得靠前很多，归功于Google2015年4越发布的Borg论文。&lt;br /&gt;
Borg承载了Google公司整个基础设施的核心依赖，在整个基础设施技术栈的最底层。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/borg.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片来源：&lt;a href=&#34;http://malteschwarzkopf.de/research/assets/google-stack.pdf&#34;&gt;http://malteschwarzkopf.de/research/assets/google-stack.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/Kubernetes.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes跟Borg非常相似，由Master+Node组成。&lt;br /&gt;
Master控制节点：&lt;br /&gt;
1. kube-apiserver 负责API服务&lt;br /&gt;
2. kube-scheduler 负责调度
3. kube-controller-manager 负责容器编排&lt;/p&gt;

&lt;p&gt;整个集群数据持久化由kube-apiserver处理后保存在Etcd中。&lt;/p&gt;

&lt;p&gt;Node计算节点最核心组件kubelet，负责同容器运行时（比如docker项目）打交道。&lt;br /&gt;
1. CRI （Container Runtime Interface）定义了容器运行时各种核心操作，比如启动一个容器需要的所有参数等。只要符合这个容器运行时能够运行标准的容器镜像，都可以通过CRI接入到Kubernetes项目。&lt;br /&gt;
2. OCI 容器运行时规范同底层的Linux操作系统进行交互，把CRI 请求翻译成Linux 操作系统的调用（操作Namespace和Cgroups等）&lt;br /&gt;
3. CNI （Container Networking Interface） 网络插件。&lt;br /&gt;
4. CSI （Container Storage Interface） 存储插件。&lt;br /&gt;
5. Kubelet通过gRPC协议同一个Device Plugin的插件进行交互，这个插件时Kubernetes项目用来管理GPU等宿主机物理设备的主要组件，也是基于Kubernetes项目进行机器学习等工作关注的功能。&lt;/p&gt;

&lt;h2 id=&#34;kubernetes-概念&#34;&gt;Kubernetes 概念&lt;/h2&gt;

&lt;p&gt;Docker Swarm + Compose项目是通过“link”，来解决多个容器的关联关系的。 Docker会在不同容器内以环境变量注入的方式传递IP，端口信息来实现多个容器的关联。&lt;/p&gt;

&lt;p&gt;Kubernetes是用“Pod”来共享Network Namespace、同一组数据卷，从而达到高效交互信息的目的。通过“Service”的服务来给应用提供访问入口。&lt;/p&gt;

&lt;p&gt;Pod 绑定 Service服务，Service服务声明IP地址等信息，作为Pod的代理入口Portal，替代Pod对外暴露一个固定的网络地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/pod.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes围绕Pod不断扩展：
1. Deployment Pod的多实例管理器。&lt;br /&gt;
2. Secret Credential信息以Secret的方式存入Etcd，启动Pod时挂载进容器。&lt;br /&gt;
3. Job 只运行一次性的Pod。&lt;br /&gt;
4. DaemonSet 每个宿主机只能运行一个副本的守护进程服务。&lt;br /&gt;
5. CronJob 定时任务。&lt;/p&gt;

&lt;p&gt;Kubernetes项目中，推崇使用“声明式API”的方式：&lt;br /&gt;
* 通过一个编排对象，比如Pod，Job等来描述管理的应用。&lt;br /&gt;
* 通过服务对象，比如Service，Secret等负责具体平台级功能。&lt;/p&gt;

&lt;p&gt;编排对象和服务对象都是API对象。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python jinja2</title>
      <link>https://zhiweiyin318.github.io/post/python-jinja2/</link>
      <pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/python-jinja2/</guid>
      
        <description>

&lt;h1 id=&#34;jinja2是啥&#34;&gt;jinja2是啥&lt;/h1&gt;

&lt;p&gt;python的模板引擎，也是Flask的模板引擎，能根据模板字符串替换，有自己的语法规则。&lt;br /&gt;
官网: &lt;a href=&#34;http://docs.jinkan.org/docs/jinja2/&#34;&gt;http://docs.jinkan.org/docs/jinja2/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ pip install jinja2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;语法定义&#34;&gt;语法定义&lt;/h2&gt;

&lt;p&gt;jinja的语法很灵活，也很丰富，下面就列举几个常用到的，详细见官网文档介绍。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;{% &amp;hellip; %} 语句（Statements）&lt;/li&gt;
&lt;li&gt;{{ &amp;hellip; }} 打印模板输出的表达式（Expressions）&lt;/li&gt;
&lt;li&gt;{# &amp;hellip; #} 注释&lt;/li&gt;
&lt;li&gt;#&amp;hellip; ## 行语句（Line Statements）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;

&lt;p&gt;除了普通的字符串变量，Jinja2还支持列表、字典和对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{{ mydict[&amp;#39;key&amp;#39;] }}
{{ mylist[3] }}
{{ mylist[myintvar] }}
{{ myobj.somemethod() }}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;获取一个变量的属性的两种方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{{ foo.bar }}
{{ foo[&amp;#39;bar&amp;#39;] }}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;控制语句&#34;&gt;控制语句&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;if&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{% if xxx %}
   xxx
{% elif %}
    xxx
{% else %}
    xxx
{% endif %}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;for&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{% for x in xx %}
  xxx
{% endfor %}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;空白控制&#34;&gt;空白控制&lt;/h3&gt;

&lt;p&gt;默认配置中，不会对空白做进一步修改，每个空白（空格，制表符，换行符等等）都会原封不动的返回，注释也会占一行。&lt;br /&gt;
可以在注释，for，if或者变量表达式的开始或者结束放一个&amp;rsquo;-&amp;lsquo;，可以移除块前或者后的空白。&lt;br /&gt;
标签和&amp;rsquo;-&amp;lsquo;之间不能有空格&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{% for item in [1,2,3,4,5,6,7,8,9]] -%}
    {{ item }}
{%- endfor %}

# 输出结果123456789&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;程序&#34;&gt;程序&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import jinja2
# 传递的参数
values = {&amp;#39;base_distro&amp;#39;: &amp;#39;centos&amp;#39;,
              &amp;#39;base_distro_tag&amp;#39;: &amp;#39;7&amp;#39;,
              &amp;#39;base_image&amp;#39;: &amp;#39;centos&amp;#39;,
              &amp;#39;namespace&amp;#39;: &amp;#39;test&amp;#39;,
              &amp;#39;tag&amp;#39;: &amp;#39;latest&amp;#39;,
              &amp;#39;maintainer&amp;#39;: &amp;#39;zhiwei yin&amp;#39;,
              &amp;#39;version&amp;#39;: &amp;#39;v1.0.0&amp;#39;,
              &amp;#39;image_name&amp;#39;: &amp;#39;demo&amp;#39;,
              &amp;#39;build_date&amp;#39;: datetime.datetime.fromtimestamp(time.time()).strftime(&amp;#39;%Y%m%d&amp;#39;)}
    
    # 模板放置目录
    path = &amp;#39;./template&amp;#39;
    
    # 创建一个loader，jinja2会从这个path加载文件
    # 用loader创建一个环境，有了它才能读取模板
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(path))
    
    #加载模板并返回
    template = env.get_template(&amp;#39;Dockerfile.j2&amp;#39;)
    
    # 完成渲染模板
    content = template.render(values)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;demo&#34;&gt;demo&lt;/h3&gt;

&lt;p&gt;demo 地址：&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/jinja2&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/jinja2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{# This is a dome file #}
FROM {{ base_image }}:{{ base_distro_tag }}
LABEL maintainer=&amp;#34;{{ maintainer }}&amp;#34; name=&amp;#34;{{ image_name }}&amp;#34; build-date=&amp;#34;{{ build_date }}&amp;#34;

LABEL version=&amp;#34;{{ version }}&amp;#34;

{% if base_image in [&amp;#39;ubuntu&amp;#39;, &amp;#39;debian&amp;#39;] %}
    {% set work_dir = &amp;#39;ubuntu&amp;#39; %}
{% else %}
    {% set work_dir = &amp;#39;centos&amp;#39; %}
{% endif %}

WORKDIR /{{ work_dir }}


{% for file in [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;] %}
COPY {{ file }} /{{ work_dir }}
{% endfor %}

RUN{% for item in [&amp;#39;yum&amp;#39;,&amp;#39;install&amp;#39;,&amp;#39;python&amp;#39;, &amp;#39;-y&amp;#39;] %} {{ item }}
{%- endfor %}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;渲染后的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;FROM centos:7
LABEL maintainer=&amp;#34;zhiwei yin&amp;#34; name=&amp;#34;demo&amp;#34; build-date=&amp;#34;20180914&amp;#34;

LABEL version=&amp;#34;v1.0.0&amp;#34;


    


WORKDIR /centos



COPY a /centos

COPY b /centos


RUN yum install python -y&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-Image</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image/</guid>
      
        <description>

&lt;h1 id=&#34;mount-namespace&#34;&gt;mount namespace&lt;/h1&gt;

&lt;p&gt;“左耳朵耗子” 叔的一篇将docker的Namespace的文章，文章地址：&lt;a href=&#34;https://coolshell.cn/articles/17010.html&#34;&gt;https://coolshell.cn/articles/17010.html&lt;/a&gt; ,里面有个小程序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/mount.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

/* 定义一个给 clone 用的栈，栈大小1M */
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];
 
char* const container_args[] = {
    &amp;#34;/bin/bash&amp;#34;,
    NULL
};

int container_main(void* arg)
{
    printf(&amp;#34;Container [%5d] - inside the container!\n&amp;#34;, getpid());
    execv(container_args[0], container_args);
    printf(&amp;#34;Something&amp;#39;s wrong!\n&amp;#34;);
    return 1;
}
 
int main()
{
    printf(&amp;#34;Parent [%5d] - start a container!\n&amp;#34;, getpid());
    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf(&amp;#34;Parent - container stopped!\n&amp;#34;);
    return 0;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;clone创建一个新的子进程，启动mount namespace（CLONE_NEWNS标志），子进程启动/bin/bash程序，这个shell就运行在mount namespace的隔离环境里。&lt;br /&gt;
编译下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw test]# gcc -o container container.c 
[root@yzw test]# ./container 
Parent [19645] - start a container!
Container [    1] - inside the container!
[root@yzw test]# ls /tmp/
test&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;发现依然能看到很多宿主机的文件。为什么mount namespace开启后，容器里面和宿主机的文件完全一样呢？&lt;br /&gt;
因为mount namespace修改的是容器进程对文件系统“挂载点”的认知，只有在“挂载”操作之后才能起作用，之前新创建的容器会继承宿主机的挂载点。&lt;br /&gt;
我们在上面程序bash操作前重新以tmpfs内存盘的格式mount /tmp目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;int container_main(void* arg)
{
    printf(&amp;#34;Container [%5d] - inside the container!\n&amp;#34;, getpid());
    //如果机器根目录的挂载类型是shared，得重新挂载根目录
    //mount(&amp;#34;&amp;#34;,&amp;#34;/&amp;#34;,NULL,MS_PRIVATE,&amp;#34;&amp;#34;)
    mount(&amp;#34;none&amp;#34;,&amp;#34;/tmp&amp;#34;,&amp;#34;tmpfs&amp;#34;,0,&amp;#34;&amp;#34;)
    execv(container_args[0], container_args);
    printf(&amp;#34;Something&amp;#39;s wrong!\n&amp;#34;);
    return 1;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;编译执行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw test]# gcc -o container container.c 
[root@yzw test]# ./container 
Parent [19861] - start a container!
Container [    1] - inside the container!
[root@yzw test]# ls /tmp/
[root@yzw test]# 
[root@yzw test]# mount -l | grep tmpfs
...
none on /tmp type tmpfs (rw,relatime,seclabel)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在宿主机上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 按理说应该是看不见的，在虚拟机里还能看到，后面再调查哈为啥？？&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;tmp目录下已经和宿主机的tmp目录内容不一致了。&lt;/p&gt;

&lt;p&gt;当新创一个容器时，在容器进程启动前重新挂载根目录，由于mount namespace的存在，这个目录对宿主机不可见，容器里面的文件系统就是一个隔离的环境了。&lt;/p&gt;

&lt;h2 id=&#34;issue&#34;&gt;issue&lt;/h2&gt;

&lt;p&gt;重新挂载/tmp目录的实验执行完成后，在宿主机上居然可以看到这个挂载信息。。这是怎么回事呢？实际上，大家自己装的虚拟机，或者云上的虚拟机的根目录，很多都是以share方式的挂载的。这时候，你在容器里做mount也会继承share方式。这样就会把容器内挂载传播到宿主机上。解决这个问题，你可以在重新挂载/tmp之前，在容器内先执行一句：mount(“”, “/“, NULL, MS_PRIVATE, “”) 这样，容器内的根目录就是private挂载的了。（没起作用?）&lt;/p&gt;

&lt;h1 id=&#34;chroot&#34;&gt;chroot&lt;/h1&gt;

&lt;p&gt;chroot可以改变进程的根目录到指定目录，把bash和ls程序以及运行需要的so文件拷贝过来:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw tmp]# mkdir -p test/{bin,lib64,lib}
[root@yzw tmp]# cd test/
[root@yzw test]# cp /bin/{bash,ls} bin/
[root@yzw test]# T=/tmp/test
[root@yzw test]# list=&amp;#34;$(ldd /bin/ls | egrep -o &amp;#39;/lib.*\.[0-9]&amp;#39;)&amp;#34;
[root@yzw test]# for i in $list; do cp -v &amp;#34;$i&amp;#34; &amp;#34;${T}${i}&amp;#34;;done
[root@yzw test]# list=&amp;#34;$(ldd /bin/bash | egrep -o &amp;#39;/lib.*\.[0-9]&amp;#39;)&amp;#34;
[root@yzw test]# for i in $list; do cp -v &amp;#34;$i&amp;#34; &amp;#34;${T}${i}&amp;#34;;done
[root@yzw tmp]# chroot /tmp/test /bin/bash
bash-4.2# ls /
bin  lib  lib64&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;bash进程的根目录被修改了，感知不到宿主机的目录，这种方式和mount namespace效果类似，mount namespace就是基于chroot改进而来的。&lt;/p&gt;

&lt;h1 id=&#34;镜像&#34;&gt;镜像&lt;/h1&gt;

&lt;p&gt;为了让容器的这个根目录真实，我们一般会把给根目录挂载一个完整的操作系统的文件系统，比如ubuntu的ISO。这样启动之后，我们ls根目录就是整个ubuntu的所有目录和文件了。这个挂载在容器根目录，用来为容器j进程提供隔离后执行环境的文件系统，就是容器镜像，还有关于专业的名称，rootfs（根文件系统）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
ededc6515049        busybox             &amp;#34;/bin/sh&amp;#34;           2 hours ago         Up 2 hours                              cranky_lichterman
[root@yzw ~]# docker exec -it ededc6515049 /bin/sh
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;进入容器执行的sh，ls程序，就是容器/bin目录下的程序，和宿主机上的sh，ls完全不一样。&lt;/p&gt;

&lt;p&gt;docker项目最核心的的原理就是为带创建的用户进程：&lt;br /&gt;
1. 启动namespace设置；&lt;br /&gt;
2. 设置指定的cgroup参数；&lt;br /&gt;
3. 切换进程的根目录；&lt;br /&gt;
docker 优先使用pivot_root系统调用，如果不支持才使用chroot。&lt;/p&gt;

&lt;p&gt;rootfs只是一个操作系统包含的文件，配置和目录，并不包括内核。linux操作系统中，内核和这些是分开的，开机时将内核加载到内存中。所有同一个宿主机上的容器公用同一个内核。如果容器应用要修改内核的配置啥的会影响这个宿主机的，这点不如虚机隔离性好。&lt;/p&gt;

&lt;p&gt;容器的一致性&lt;/p&gt;

&lt;p&gt;不管是本地，还是云端，还是任何一个机器，用户只要解压打包好的rootfs，这个应用就能跑起来。解决了PaaS打包的大问题。&lt;/p&gt;

&lt;p&gt;如果一个rootfs做好，另外一个应用像在这个上面进行修改，再发布，这样维护起来比较麻烦，不具备扩展性。docker公司引入了layer的概念，用户制作镜像的每一个步骤，都会生成一个layer，就是一个增量的rootfs。&lt;/p&gt;

&lt;p&gt;Docker 的storage driver除了支持AUFS外，还支持devicemapper，overlayer，btrfs等，现在Docker CE默认为overlayer2，如果后端是direct-LVM的话，会默认为devicemapper。通过docker info可以查询到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw ~]# docker info
Containers: 1
 Running: 1
 Paused: 0
 Stopped: 0
Images: 109
Server Version: 18.06.1-ce
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;aufs&#34;&gt;AUFS&lt;/h2&gt;

&lt;p&gt;联合文件系统（union file system） unionFS最主要的功能就是可以将多个不同位置的目录联合挂载在同一个目录下。AUFS全称Another UnionFS，后面又叫Alternative UnionFS，再后就又叫Advance UnionFS，只能在ubuntu和Debian上使用，因为没有被Linus合入linux主分干，下面例子在Ubuntu上跑的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/tmp# tree
.
├── A
│   ├── a
│   └── x
├── B
│   ├── b
│   └── x
└── C

3 directories, 4 files
root@yzw-vm:/tmp# cat A/x
a
root@yzw-vm:/tmp# cat B/x
b
root@yzw-vm:/tmp# mount -t aufs -o dirs=./A:./B none ./C
root@yzw-vm:/tmp# tree
.
├── A
│   ├── a
│   └── x
├── B
│   ├── b
│   └── x
└── C
    ├── a
    ├── b
    └── x
3 directories, 7 files
root@yzw-vm:/tmp# cat C/x
a
root@yzw-vm:/tmp# df -h
Filesystem      Size  Used Avail Use% Mounted on
...
none             59G   22G   34G  40% /tmp/C
root@yzw-vm:/tmp# echo &amp;#34;c&amp;#34; &amp;gt; C/x
root@yzw-vm:/tmp# cat C/x
c
root@yzw-vm:/tmp# cat A/x
c
root@yzw-vm:/tmp# cat B/x
b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;合并后的C目录，x只有一份，通过“写时复制策略实现镜像的共享和最小化磁盘开销。对C中的文件进行修改，A，B 中对应文件也会生效(相同文件存在覆盖除外)。&lt;/p&gt;

&lt;p&gt;AUFS工作在文件的层次上，也就是说AUFS对文件的操作需要将整个文件复制到读写层内，哪怕只是文件的一小部分被改变，也需要复制整个文件。这在一定成度上会影响容器的性能，尤其是当要复制的文件很大，文件在栈的下面几层或文件在目录中很深的位置时，对性能的影响会很显著。&lt;/p&gt;

&lt;p&gt;通过“写时复制（CoW）”策略实现镜像的共享和最小化磁盘开销。任何对于底层文件系统分层的更改都会被“向上拷贝”到文件系统的一个临时、工作、或高层的分层里面。这个可写的层然后可以被看做是一个“改动（diff）”，能将之应用到下层只读的层，而这些层很可能作为底层被很多容器的进程中共享。&lt;/p&gt;

&lt;p&gt;一个Docker中使用分层文件系统的好处就是，1000个运行着bash的ubuntu:latest容器的副本，会共享一个底层的镜像，而并不会产生1000个文件系统的副本（vfs是个例外，请参考下边vfs部分）。并且同样重要的是，对于aufs和overlay的实现，用来读取或执行共享库的共享内存也在所有运行的容器之间共享，大大的减少了通用库如&amp;rsquo;libc&amp;rsquo;的内存占用。&lt;/p&gt;

&lt;h3 id=&#34;issue-1&#34;&gt;issue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;目录联合挂载时，如果A和B目录里的x文件内容不一样，这时如何处理？&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;aufs是一层一层往上盖的，所以我给的例子里，A里面的x会覆盖B里面的x.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/tmp# mount -t aufs -o dirs=./B:./A none ./C
root@yzw-vm:/tmp# tree
.
├── A
│   ├── a
│   └── x
├── B
│   ├── b
│   └── x
└── C
    ├── a
    ├── b
    └── x

3 directories, 7 files
root@yzw-vm:/tmp# cat C/x
b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;没有内核所以rootfs会比较小，请问一般安装的linux系统内核文件在哪里存放呢？
首先，docker镜像比较小不只是因为没有内核，内核本身其实不大。大小的差异主要因为我们平常看见的虚拟机镜像实际上是整个磁盘的快照。其次，一般情况下，内核放下安装盘里，解压到磁盘上，加载到内存中。有兴趣可以读这里：&lt;a href=&#34;https://blog.csdn.net/gatieme/article/details/50914250&#34;&gt;https://blog.csdn.net/gatieme/article/details/50914250&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;devicemapper&#34;&gt;devicemapper&lt;/h2&gt;

&lt;p&gt;早期Docker在Debian，Ubuntu系统中默认使用AUFS，RedHat系统用devicemapper。devicemapper是红帽系主推的。&lt;/p&gt;

&lt;p&gt;devicemapper是基于块设备的，不是基于文件的。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。&lt;/p&gt;

&lt;h2 id=&#34;overlay2&#34;&gt;overlay2&lt;/h2&gt;

&lt;h3 id=&#34;overlay2是什么&#34;&gt;overlay2是什么&lt;/h3&gt;

&lt;p&gt;Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，将着两个layers联合挂载后就是一个做为文件系统合并视图的“合并（merged）”目录。镜像层和容器曾可以有相同的文件，这中情况下，upperdir中的文件覆盖lowerdir中的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/overlay_constructs.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。&lt;br /&gt;
Overlay2支持多个下层目录，最多128个，解决了Overlay的inode耗尽的问题，继承了Overlay很多优点，包括包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。&lt;/p&gt;

&lt;p&gt;Docker 配置使用overlay2：&lt;a href=&#34;https://docs.docker.com/storage/storagedriver/overlayfs-driver/#configure-docker-with-the-overlay-or-overlay2-storage-driver&#34;&gt;https://docs.docker.com/storage/storagedriver/overlayfs-driver/#configure-docker-with-the-overlay-or-overlay2-storage-driver&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;举个例子&#34;&gt;举个例子&lt;/h3&gt;

&lt;p&gt;看下ubuntu镜像由5层构成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:~# docker pull ubuntu:latest
latest: Pulling from library/ubuntu
124c757242f8: Pull complete 
9d866f8bde2a: Pull complete 
fa3f2f277e67: Pull complete 
398d32b153e8: Pull complete 
afde35469481: Pull complete 
Digest: sha256:de774a3145f7ca4f0bd144c7d4ffb2931e06634f11529653b23eba85aef8e378
Status: Downloaded newer image for ubuntu:latest

root@yzw-vm:~# docker image inspect ubuntu
[
...
       &amp;#34;GraphDriver&amp;#34;: {
            &amp;#34;Data&amp;#34;: {
                &amp;#34;LowerDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339/diff:/var/lib/docker/overlay2/b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438/diff:/var/lib/docker/overlay2/098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314/diff:/var/lib/docker/overlay2/a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/diff&amp;#34;,
                &amp;#34;MergedDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/merged&amp;#34;,
                &amp;#34;UpperDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/diff&amp;#34;,
                &amp;#34;WorkDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/work&amp;#34;
            },
            &amp;#34;Name&amp;#34;: &amp;#34;overlay2&amp;#34;
        },
        &amp;#34;RootFS&amp;#34;: {
            &amp;#34;Type&amp;#34;: &amp;#34;layers&amp;#34;,
            &amp;#34;Layers&amp;#34;: [
                &amp;#34;sha256:a30b835850bfd4c7e9495edf7085cedfad918219227c7157ff71e8afe2661f63&amp;#34;,
                &amp;#34;sha256:6267b420796f78004358a36a2dd7ea24640e0d2cd9bbfdba43bb0c140ce73567&amp;#34;,
                &amp;#34;sha256:f73b2816c52ac5f8c1f64a1b309b70ff4318d11adff253da4320eee4b3236373&amp;#34;,
                &amp;#34;sha256:6a061ee02432e1472146296de3f6dab653f57c109316fa178b40a5052e695e41&amp;#34;,
                &amp;#34;sha256:8d7ea83e3c626d5ef1e6a05de454c3fe8b7a567db96293cb094e71930dba387d&amp;#34;
            ]
        },
...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在/var/lib/docker/overylay2目录下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt
total 156
drwx------ 4 root root 4096 Sep 12 11:25 ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0
drwx------ 2 root root 4096 Sep 12 11:25 l
drwx------ 4 root root 4096 Sep 12 11:25 c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339
drwx------ 4 root root 4096 Sep 12 11:25 b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438
drwx------ 4 root root 4096 Sep 12 11:25 098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314
drwx------ 3 root root 4096 Sep 12 11:25 a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412
...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;l目录包含了很多软连接，使用短名称指向了其他层。短名称用于避免mount参数时达到页面大小的限制。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt l/
total 152
lrwxrwxrwx 1 root root 72 Sep 12 11:25 AKSNN53ER6ZYNOBNG66LKFO64B -&amp;gt; ../ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 INN4Q6OLITXODWESIJWDCOU7W5 -&amp;gt; ../c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 USMKDHE2W2PPV64EAYHRKEJQDX -&amp;gt; ../b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 JGVKVFIFNC4A2SCJW2MTBLPCJK -&amp;gt; ../098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314/diff
lrwxrwxrwx 1 root root 72 Sep 12 11:25 2XXDFCYHLGAYYD4NHPEYWAQRAN -&amp;gt; ../a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/diff&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;link文件里是l目录下这个目录的短名称，diff目录就是镜像内容，lower文件指出了该层的组成，由高层到低层；work目录？？？&lt;/p&gt;

&lt;p&gt;最底层目录只有diff目录和link文件。其他底层目录除了diff，link外还有lower文件和work目录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls 098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/
diff  link
root@yzw-vm:/var/lib/docker/overlay2# ls a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/diff/
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@yzw-vm:/var/lib/docker/overlay2# cat a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412/link 
2XXDFCYHLGAYYD4NHPEYWAQRAN
root@yzw-vm:/var/lib/docker/overlay2# cat ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0/lower 
l/INN4Q6OLITXODWESIJWDCOU7W5:l/USMKDHE2W2PPV64EAYHRKEJQDX:l/JGVKVFIFNC4A2SCJW2MTBLPCJK:l/2XXDFCYHLGAYYD4NHPEYWAQRAN&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;容器运行起来后多了2个目录，读写层和初始层：&lt;/p&gt;

&lt;p&gt;merged（挂载点）： 容器根目录。&lt;br /&gt;
/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged&lt;/p&gt;

&lt;p&gt;upperdir（容器层）：初始时这个读写层时空的。&lt;br /&gt;
/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/diff&lt;/p&gt;

&lt;p&gt;lowerdir（镜像层）：总共6层，除了image的5层外，多了一个init层。&lt;br /&gt;
/var/lib/docker/overlay2/l/LC4OCZQCW7HCEKLXMY4AIYBT7U&lt;br /&gt;
/var/lib/docker/overlay2/l/AKSNN53ER6ZYNOBNG66LKFO64B&lt;br /&gt;
/var/lib/docker/overlay2/l/INN4Q6OLITXODWESIJWDCOU7W5&lt;br /&gt;
/var/lib/docker/overlay2/l/USMKDHE2W2PPV64EAYHRKEJQDX&lt;br /&gt;
/var/lib/docker/overlay2/l/JGVKVFIFNC4A2SCJW2MTBLPCJK&lt;br /&gt;
/var/lib/docker/overlay2/l/2XXDFCYHLGAYYD4NHPEYWAQRAN&lt;/p&gt;

&lt;p&gt;workdir：是用来完成如copy-on_write的操作。&lt;br /&gt;
/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work&lt;/p&gt;

&lt;p&gt;init层，这个位于只读层和读写层之间，docker项目单独生成的一个内部层，专门用来存/etc/hosts，/etc/resolv.conf等信息，这些原本属于ubuntu镜像一部分，但是用户往往需要在启动容器时写入一些指定的值比如hostname，需要在可读性层对他们进行修改。  这些修改支队当前容器有效，在docker commit时，不会把这一层提交掉，只会提交读写层。&lt;/p&gt;

&lt;p&gt;/etc/hosts, /etc/resolv.conf和/etc/hostname，容器中的这三个文件不存在于镜像，而是存在于/var/lib/docker/containers/&lt;container_id&gt;，在启动容器的时候，通过mount的形式将这些文件挂载到容器内部。&lt;/p&gt;

&lt;p&gt;修改容器里面/etc/hostname的内容，会在/var/lib/docker/containers/xxx/hostname看到修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/ubuntu-image-layer.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;容器内部的所有修改都在可读写层，docker commit和push保存的也是这个可读写层。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# docker run -it -d ubuntu /bin/bash
13d8a0e5162bfa3e087d20eef15a3805136ba2c2d6413356078ada71886639d4
root@yzw-vm:/var/lib/docker/overlay2# df -h
Filesystem      Size  Used Avail Use% Mounted on
...
tmpfs           395M   28K  395M   1% /run/user/120
tmpfs           395M   28K  395M   1% /run/user/1000
tmpfs           395M     0  395M   0% /run/user/0
overlay          59G   22G   35G  38% /var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged
shm              64M     0   64M   0% /var/lib/docker/containers/13d8a0e5162bfa3e087d20eef15a3805136ba2c2d6413356078ada71886639d4/mounts/shm

root@yzw-vm:/var/lib/docker/overlay2# mount | grep overlay
overlay on /var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/LC4OCZQCW7HCEKLXMY4AIYBT7U:/var/lib/docker/overlay2/l/AKSNN53ER6ZYNOBNG66LKFO64B:/var/lib/docker/overlay2/l/INN4Q6OLITXODWESIJWDCOU7W5:/var/lib/docker/overlay2/l/USMKDHE2W2PPV64EAYHRKEJQDX:/var/lib/docker/overlay2/l/JGVKVFIFNC4A2SCJW2MTBLPCJK:/var/lib/docker/overlay2/l/2XXDFCYHLGAYYD4NHPEYWAQRAN,upperdir=/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/diff,workdir=/var/lib/docker/overlay2/e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在容器内部可以看到overlay和shm两个文件挂载到根目录和/dev/shm目录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@13d8a0e5162b:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay          59G   22G   35G  38% /
tmpfs            64M     0   64M   0% /dev
tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup
/dev/sda1        59G   22G   35G  38% /etc/hosts
shm              64M     0   64M   0% /dev/shm
tmpfs           2.0G     0  2.0G   0% /proc/acpi
tmpfs           2.0G     0  2.0G   0% /proc/scsi
tmpfs           2.0G     0  2.0G   0% /sys/firmware&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各个layer目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt
total 32
drwx------ 5 root root 4096 Sep 12 14:23 e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a
drwx------ 4 root root 4096 Sep 12 14:23 e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init
drwx------ 2 root root 4096 Sep 12 14:23 l
drwx------ 4 root root 4096 Sep 12 11:25 ff432dd74bd7f4b941c667517c450bb75e7af61eda23a005d75db6e9b812d0e0
drwx------ 4 root root 4096 Sep 12 11:25 c9f2c1bb3948f7d2ccd2b84e13b317b0a41fb47c35b89bf6d2a7b19f3e81b339
drwx------ 4 root root 4096 Sep 12 11:25 b0f87a2c50b9b290269ee5ee55ce06dae5b877dc740cbc9ce3103476818d3438
drwx------ 4 root root 4096 Sep 12 11:25 098182c0afb45de2f0f8911a95d3bcb282e130dbeea4f9ea8c1f0899d267b314
drwx------ 3 root root 4096 Sep 12 11:25 a708ff445d90980fd58da00dd9b2fc2917ef61cb3b1aaed9bda7ea44aba12412
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a
diff  link  lower  merged  work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/diff/
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/merged/
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work/
work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/work/work/
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/link 
A4DRDBGDJJI2XIR7VGQ4T2WOFF
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a/lower 
l/LC4OCZQCW7HCEKLXMY4AIYBT7U:l/AKSNN53ER6ZYNOBNG66LKFO64B:l/INN4Q6OLITXODWESIJWDCOU7W5:l/USMKDHE2W2PPV64EAYHRKEJQDX:l/JGVKVFIFNC4A2SCJW2MTBLPCJK:l/2XXDFCYHLGAYYD4NHPEYWAQRAN
root@yzw-vm:/var/lib/docker/overlay2# 
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/
diff  link  lower  work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/diff/
dev  etc
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/work/
work
root@yzw-vm:/var/lib/docker/overlay2# ls e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/work/work/
root@yzw-vm:/var/lib/docker/overlay2# 
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/link 
LC4OCZQCW7HCEKLXMY4AIYBT7U
root@yzw-vm:/var/lib/docker/overlay2# cat e6f0c6c4c30099c6903e0c65fdeb46de4f9ed4d1d71338a54480f66f0b00010a-init/lower 
l/AKSNN53ER6ZYNOBNG66LKFO64B:l/INN4Q6OLITXODWESIJWDCOU7W5:l/USMKDHE2W2PPV64EAYHRKEJQDX:l/JGVKVFIFNC4A2SCJW2MTBLPCJK:l/2XXDFCYHLGAYYD4NHPEYWAQRAN
root@yzw-vm:/var/lib/docker/overlay2# &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;容器使用overlay读写&#34;&gt;容器使用overlay读写&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;读容器层不存在的文件：&lt;br /&gt;
从镜像层中读取，有小的性能损耗。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;读只存在于容器层的文件：&lt;br /&gt;
直接读取，不拷贝，无额外性能损耗。&lt;/li&gt;
&lt;li&gt;读同时存在于容器和镜像层的文件：&lt;br /&gt;
直接读取容器层文件，因为容器层隐藏了镜像层的同名文件。无额外性能损耗。&lt;/li&gt;
&lt;li&gt;写一个文件：
容器写一个已经存在的文件，容器层不存在这个文件，overlay会将整个文件拷贝到容器层进行修改，拷贝只发生在第一次写入文件时，后面就直接容器层写了。&lt;br /&gt;
OverlayFS只工作在两层中。这比AUFS要在多层镜像中查找时性能要好。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;删除文件和目录：&lt;br /&gt;
删除文件时，容器层会镜像层创建一个whiteout文件，而镜像层的文件并没有被删，whiteout文件会隐藏它。例如删除一个foo文件，容器层创建一个.wh.foo的文件，当这两层被联合挂载之后，foo文件就会被.wh.foo文件遮挡起来消失了。翻译成“白障”。
删除目录时，容器层会创建一个不透明目录，和whiteout文件隐藏镜像层文件类似。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重命名目录：&lt;br /&gt;
只有在源路径和目的路径都在顶层容器层时，才允许执行rename操作。否则，会返回EXDEV。因此，你的应用需要能够处理EXDEV，并且回滚操作，执行替代的“拷贝和删除”策略。&lt;strong&gt;（没理解）&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;

&lt;p&gt;引用: &lt;a href=&#34;https://arkingc.github.io/2017/05/05/docker-filesystem-overlay/&#34;&gt;https://arkingc.github.io/2017/05/05/docker-filesystem-overlay/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般来说，overlay/overlay2很快，几乎肯定比aufs和devicemapper快。在某些特定场景下，还可能比btrfs快。 此外，还有几点overlay/overlay2驱动性能相关的注意事项：&lt;/p&gt;

&lt;p&gt;页缓存：OverlayFS支持页缓存共享，意味着多个容器访问相同的文件能够共享一个单一的page cache entry。 使得overlay/overlay2驱动能高效使用内存，是PaaS以及其它高密度场景一个好的选择。&lt;/p&gt;

&lt;p&gt;copy_up：对镜像层大文件进行写操作时，copy-on-write会给写操作带来大量延迟。&lt;/p&gt;

&lt;p&gt;inode 限制：使用overlay会引起过度的inode消耗，消耗会随着主机上的镜像和容器的增加而增加。 拥有大量镜像的主机在大量容器启动和停止时可能会耗尽inodes。 不幸的是你只能在文件系统创建时指定inode数，因此你可能需要考虑将/var/lib/docker放在另一个独立的设备上， 或者在创建文件系统时手动修改inode值。而overlay2则没有这样的问题。&lt;/p&gt;

&lt;p&gt;RPM和Yum：OverlayFS仅实现了POSIX标准的一部分，某些操作还会违反POSIX标准，copy_up操作就是其中一个。&lt;/p&gt;

&lt;p&gt;下面是提升OverlayFS驱动性能的最佳实践。&lt;/p&gt;

&lt;p&gt;SSD：为了获得最佳性能，一个通常的想法是使用诸如SSD这类更快的存储设备；&lt;/p&gt;

&lt;p&gt;使用数据卷： 数据卷提供了最好的以及最可预见的性能。 因为绕过了存储驱动，因此不会存在瘦供给和copy-on-write带来的潜在性能开销。 因此，写操作较频繁的数据应该放在数据卷上。&lt;/p&gt;

&lt;h1 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h1&gt;

&lt;p&gt;python:2.7-slim基础镜像一共有4层layer。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/home/yzw/docker# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
python              2.7-slim            c9cde4658340        7 days ago          120MB
root@yzw-vm:/home/yzw/docker# ls -l /var/lib/docker/overlay2/
total 20
drwx------ 4 root root 4096 Sep 12 22:07 0111758e6c9c78c7ae33a181232bf15aa1fc9c314d1b9cacd9506541065a7379
drwx------ 2 root root 4096 Sep 12 22:07 l
drwx------ 4 root root 4096 Sep 12 22:07 4560378751a6edaa1b7ed848d632310eaf96431d9643792a5d2462b315263c0e
drwx------ 4 root root 4096 Sep 12 22:07 f6a44ab116768ddf5ba69b2f9601a627ececb2d9d20b6a5956bf97818fd46691
drwx------ 3 root root 4096 Sep 12 22:07 897596fd5f4efb3890c0801cb3813374fb9c40513f172bf2bf05f3f0c9e37d4b&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;基于python:2.7-slim基础镜像build一个新的镜像&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/home/yzw/docker# cat Dockerfile 
FROM python:2.7-slim
WORKDIR /app
ADD . /app
RUN pip install --trusted-host pypi.python.org -r requirements.txt
EXPOSE 80
ENV NAME World
CMD [&amp;#34;python&amp;#34;,&amp;#34;app.py&amp;#34;]

root@yzw-vm:/home/yzw/docker# docker build -t helloworld .
...
root@yzw-vm:/home/yzw/docker# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
helloword           latest              7c6f3f79a9d1        30 minutes ago      131MB
python              2.7-slim            c9cde4658340        7 days ago          120MB&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在python基础镜像的基础上多出了3个layer，WORKDIR，ADD，RUN每一个操作会生成一个layer&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/var/lib/docker/overlay2# ls -lt
total 32
drwx------ 2 root root 4096 Sep 12 22:10 l
drwx------ 4 root root 4096 Sep 12 22:10 4463cacc12fd606d136c25228be202afba963954ea3b90b9aa22e760230eb559
drwx------ 4 root root 4096 Sep 12 22:09 1c6de6d90e60da84614b9ffe7147ccc3465e9d301445161f1c8d0b8bdb3e8044
drwx------ 4 root root 4096 Sep 12 22:09 44744bbff15cfb1a73c168cee6d23b4e99458d5c4a72199a310016d7ebd4e28d
drwx------ 4 root root 4096 Sep 12 22:07 0111758e6c9c78c7ae33a181232bf15aa1fc9c314d1b9cacd9506541065a7379
drwx------ 4 root root 4096 Sep 12 22:07 4560378751a6edaa1b7ed848d632310eaf96431d9643792a5d2462b315263c0e
drwx------ 4 root root 4096 Sep 12 22:07 f6a44ab116768ddf5ba69b2f9601a627ececb2d9d20b6a5956bf97818fd46691
drwx------ 3 root root 4096 Sep 12 22:07 897596fd5f4efb3890c0801cb3813374fb9c40513f172bf2bf05f3f0c9e37d4b
root@yzw-vm:/var/lib/docker/overlay2# ls -lt 44744bbff15cfb1a73c168cee6d23b4e99458d5c4a72199a310016d7ebd4e28d/diff/app
total 0
root@yzw-vm:/var/lib/docker/overlay2# ls -lt 1c6de6d90e60da84614b9ffe7147ccc3465e9d301445161f1c8d0b8bdb3e8044/diff/app/
total 12
-rw-r--r-- 1 root root 168 Sep 12 22:08 Dockerfile
-rw-r--r-- 1 root root   6 Sep 12 22:01 requirements.txt
-rw-rw-r-- 1 root root 324 Sep 12 21:59 app.py
root@yzw-vm:/var/lib/docker/overlay2# ls -lt 4463cacc12fd606d136c25228be202afba963954ea3b90b9aa22e760230eb559/diff
total 12
drwxrwxrwt 2 root root 4096 Sep 12 22:10 tmp
drwx------ 3 root root 4096 Sep 12 22:09 root
drwxr-xr-x 3 root root 4096 Aug 31 08:00 usr&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-exec-volume</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-exec-volume/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-exec-volume/</guid>
      
        <description>

&lt;h1 id=&#34;docker-exec-是怎么进入容器的&#34;&gt;docker exec 是怎么进入容器的？&lt;/h1&gt;

&lt;p&gt;容器进程python2，docker exec又重新拉起来了进程跟python2进程都是docker-containerd-shim的子进程。docker exec又是怎么进入 python2进程的Namespace的呢?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/home/yzw/docker# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
9e4bdd819dc0        python:2.7-slim     &amp;#34;python2&amp;#34;           3 seconds ago       Up 1 second                             flamboyant_darwin
root@yzw-vm:/home/yzw/docker# ps auxf
...
root      1488  0.3  1.9 1405040 78288 ?       Ssl  11:53   2:20 /usr/bin/dockerd -H fd://
root      1743  0.2  0.8 1319652 35928 ?       Ssl  11:53   1:30  \_ docker-containerd --config /var/run/docker/containerd/containerd.toml
root     11223  0.0  0.1   7500  4080 ?        Sl   23:07   0:00      \_ docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/9e4bdd819dc0b462eb
root     11243  0.0  0.1  30084  7764 pts/0    Ss+  23:07   0:00          \_ python2

root@yzw-vm:/home/yzw/docker# docker exec -it 9e4bdd819dc0 /bin/bash
root@9e4bdd819dc0:/# 

root@yzw-vm:/home/yzw/docker# ps auxf
...
root      1488  0.3  1.9 1405040 78208 ?       Ssl  11:53   2:21 /usr/bin/dockerd -H fd://
root      1743  0.2  0.8 1319652 35928 ?       Ssl  11:53   1:31  \_ docker-containerd --config /var/run/docker/containerd/containerd.toml
root     11223  0.0  0.0   7500  4020 ?        Sl   23:07   0:00      \_ docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/9e4bdd819dc0b462eb
root     11243  0.0  0.1  30084  7764 pts/0    Ss+  23:07   0:00          \_ python2
root     11367  0.0  0.0  19952  3444 pts/1    Ss+  23:12   0:00          \_ /bin/bash&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Linux Namespace 创建了一个隔离的空间，但是一个进程的Namespace在宿主机上是以文件形式存在着的，进程的每一个namespace都链接到一个真是的文件。&lt;/p&gt;

&lt;p&gt;一个进程，可以加入到某个进程已有的Namespace当中，达到进入这个进程所在容器的目的，就是exec的实现原理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/home/yzw/docker# docker inspect --format ‘{{.State.Pid}}’ 9e4bdd819dc0
‘11243’
root@yzw-vm:/home/yzw/docker# ls -l /proc/11243/ns
total 0
lrwxrwxrwx 1 root root 0 Sep 12 23:25 cgroup -&amp;gt; &amp;#39;cgroup:[4026531835]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:12 ipc -&amp;gt; &amp;#39;ipc:[4026532239]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:12 mnt -&amp;gt; &amp;#39;mnt:[4026532237]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:07 net -&amp;gt; &amp;#39;net:[4026532242]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:12 pid -&amp;gt; &amp;#39;pid:[4026532240]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:25 pid_for_children -&amp;gt; &amp;#39;pid:[4026532240]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:25 user -&amp;gt; &amp;#39;user:[4026531837]&amp;#39;
lrwxrwxrwx 1 root root 0 Sep 12 23:12 uts -&amp;gt; &amp;#39;uts:[4026532238]&amp;#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个操作依赖一个setns()的系统调用。将需要进入的Namespace的文件描述符fd交给setns()，就可以将当前进程加入到这个Namespace里面了。下面小程序传入2个参数，一个是Namespace的文件名，第二个是执行的程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

#define errExit(msg) do { perror(msg);exit(EXIT_FAILURE);} while(0)

int main(int argc, char *argv[]){
    int fd;
    fd =open(argv[1],O_RDONLY);
    if (setns(fd,0) == -1){
        errExit(&amp;#34;setns&amp;#34;);
    }
    execvp(argv[2],&amp;amp;argv[2]);
    errExit(&amp;#34;execvp&amp;#34;);
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;编译后，传入mnt的namespace文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/home/yzw/docker# gcc -o setnc setns.c 

root@yzw-vm:/home/yzw/docker# docker exec -it 9e4bdd819dc0 /bin/bash
root@9e4bdd819dc0:/# cd /home/
root@9e4bdd819dc0:/home# ls
root@9e4bdd819dc0:/home# touch abc
root@9e4bdd819dc0:/home# ls
abc


root@yzw-vm:/home/yzw/docker# ./setnc /proc/11243/ns/mnt /bin/bash
root@yzw-vm:/# ls
bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  srv  sys  tmp  usr  var
root@yzw-vm:/# ls /home/
abc
root@yzw-vm:/# &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;查下新启的bin/bash的进程的PID的mnt Namespace，和python2进程的一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;root@yzw-vm:/home/yzw/docker# ps axuf | grep /bin/bash
root     11863  0.0  0.0  18204  3156 pts/4    S+   23:57   0:00  |                       \_ /bin/bash
root     11866  0.0  0.0  21536  1084 pts/5    S+   23:57   0:00                          \_ grep --color=auto /bin/bash
root@yzw-vm:/home/yzw/docker# ls -l /proc/11863/ns/mnt 
lrwxrwxrwx 1 root root 0 Sep 12 23:57 /proc/11863/ns/mnt -&amp;gt; &amp;#39;mnt:[4026532237]&amp;#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;docker-volume-是怎么实现的&#34;&gt;docker volume 是怎么实现的？&lt;/h1&gt;

&lt;p&gt;docker volume又2种声明方式,比如把宿主机目录挂进容器/test目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 在宿主机/var/lib/docker/volumes/xxx/_data 挂到容器/test目录
$ docker run -v /test ...
# 把宿主机/home目录挂到容器/test目录
$ docker run -v /home:/test ...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;docker怎么把宿主机上的目录挂到容器里面的？&lt;/p&gt;

&lt;p&gt;前面namespace总结中，当容器进程（dockerinit 容器初始化进程）被创建之后，尽管开启了Mount Namespace，但是它执行chroot或者pivot_root之前，容器进程一直可以看到宿主机上整个文件系统。宿主机上的容器镜像的各个层，在容器进程启动后，就会被联合挂载到/var/lib/docker/overlay2/xxx/merged目录中，这样容器的rootfs就准备好了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;容器启动进程dockerinit，而不是应用进程ENTRYPOINT+CMD,dockerinit负责完成根目录准备，挂载设备目录配置hostname一系列初始化工作，然后通过execv()，让应用程序取代自己，成为PID=1的进程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;只需要在rootfs准备好之后，chroot之前，把volume指定的目录，挂载到容器指定目录在宿主机上对应的目录（/var/lib/docker/overlay2/读写层/test），就可以了。这时候Mount Namespace已经开启，挂载后，容器里面是可见的，宿主机上看不到容器里面的挂载点，容器的隔离性不好被volume打破。&lt;/p&gt;

&lt;p&gt;这里用到的挂载技术，就是Linux的绑定挂载 bind mount 机制，主要作用就是将一个目录/文件，而不是一个设备，挂载到一个指定目录上。并且，这时候你在该挂载点上进行的任何操作，发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来，不受影响。&lt;/p&gt;

&lt;p&gt;绑定挂载实际上是一个inode替换的过程，indoe可以理解为存放文件内容的“对象”，dentry，目录项，就是访问inode所使用的“指针”。 bind mount相当于/test的dentry，重定向到/home的inode。当修改/test目录，实际是修改/home目录的inode。一旦umount后，/test目录原先的内容会恢复。&lt;/p&gt;

&lt;p&gt;这个/test目录的内容，是挂载在容器rootfs的可读写层，是不会被docker commit提交的，以为docker commint是发生在宿主机空间，由于mount namespace的隔离，不知道绑定挂载的存储，所有/test目录会被打包，出现在新的镜像里面的，但是里面是空的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Python docker-client</title>
      <link>https://zhiweiyin318.github.io/post/python-docker-client/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/python-docker-client/</guid>
      
        <description>

&lt;p&gt;简单记录哈python的docker client的使用。&lt;br /&gt;
&amp;gt; 官方文档：&lt;br /&gt;
&amp;gt; &lt;a href=&#34;https://docker-py.readthedocs.io/en/stable/client.html&#34;&gt;https://docker-py.readthedocs.io/en/stable/client.html&lt;/a&gt;&lt;br /&gt;
&amp;gt; &lt;a href=&#34;https://docs.docker.com/develop/sdk/examples/&#34;&gt;https://docs.docker.com/develop/sdk/examples/&lt;/a&gt;&lt;br /&gt;
&amp;gt; demo地址：&lt;br /&gt;
&amp;gt; &lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/dockerclient&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/dockerclient&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ pip install docker&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;

&lt;h2 id=&#34;client-初始化&#34;&gt;client 初始化&lt;/h2&gt;

&lt;p&gt;需要先创建一个DockerClient类的对象，相当于本地的docker client端。有三种方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker

# 方式1 base_url 可以是socket或者tcp方式，还有version，timeout等参数
dc = docker.APIClient(base_url=&amp;#39;unix://var/run/docker.sock&amp;#39;,timeout=5)
# 方式2
docker_kwargs = docker.utils.kwargs_from_env()
dc = docker.APIClient(version=&amp;#39;auto&amp;#39;, **docker_kwargs)
# 方式3 这是上面2个的子集
dc = docker.from_env()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;client-的方法&#34;&gt;client 的方法&lt;/h2&gt;

&lt;p&gt;client对象的有一些方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;dc.configs
dc.containers
dc.images
dc.networks
dc.nodes
dc.plugins
dc.volumes
dc.services
dc.events
...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;运行-查询-停止-删除-一个容器&#34;&gt;运行，查询，停止，删除 一个容器&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import docker
&amp;gt;&amp;gt;&amp;gt; dc = docker.from_env()
&amp;gt;&amp;gt;&amp;gt; dc.containers.run(&amp;#34;busybox&amp;#34;,&amp;#39;echo hello world&amp;#39;)
&amp;#39;hello world\n&amp;#39;
&amp;gt;&amp;gt;&amp;gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.from_env()
container = dc.containers.run(&amp;#34;busybox&amp;#34;, name=&amp;#39;test&amp;#39;, command=&amp;#39;echo hello world&amp;#39;, detach=True, tty=True,
                                stdin_open=True)
print container.logs()
print &amp;#34;containers: {}&amp;#34;.format(dc.containers.list())
print &amp;#34;container {} status is {}&amp;#34;.format(container.name, container.status)
container.stop()
container.remove()
print &amp;#34;container {} status is {}&amp;#34;.format(container.name, container.status)
print &amp;#34;containers: {}&amp;#34;.format(dc.containers.list())&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;list-pull-image&#34;&gt;list/pull image&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.from_env()
for i in dc.images.list():
    print &amp;#34;image ID:{}, tag:{}&amp;#34;.format(i.short_id, i.tags)
    for t in i.tags:
        if t == &amp;#34;busybox:latest&amp;#34;:
            print &amp;#34;remove image {}&amp;#34;.format(t)
            dc.images.remove(&amp;#39;busybox:latest&amp;#39;)

# if no tag is specified all tags from the repo will be pulled.
image = dc.images.pull(&amp;#39;busybox:latest&amp;#39;)
print &amp;#34;pull busybox image, id:{},tag:{}&amp;#34;.format(image.short_id, image.tags)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;low-level-api&#34;&gt;Low-level API&lt;/h2&gt;

&lt;p&gt;The main object-orientated API is built on top of APIClient. Each method on APIClient maps one-to-one with a REST API endpoint, and returns the response that the API responds with.&lt;/p&gt;

&lt;p&gt;It’s possible to use APIClient directly. Some basic things (e.g. running a container) consist of several API calls and are complex to do with the low-level API, but it’s useful if you need extra flexibility and power.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.APIClient(base_url=&amp;#39;unix://var/run/docker.sock&amp;#39;)
    print dc.version()
dc.containers()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;等同于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;import docker
dc = docker.from_env()
dc.api.containers()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;输出结果是json结构的map&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[{u&amp;#39;Status&amp;#39;: u&amp;#39;Up Less than a second&amp;#39;, u&amp;#39;Created&amp;#39;: 1536673589, u&amp;#39;Image&amp;#39;: u&amp;#39;busybox&amp;#39;, u&amp;#39;Labels&amp;#39;: {}, u&amp;#39;NetworkSettings&amp;#39;: {u&amp;#39;Networks&amp;#39;: {u&amp;#39;bridge&amp;#39;: {u&amp;#39;NetworkID&amp;#39;: u&amp;#39;754e02dfae9aa61b96e78ca6dfa743f121177c2985cd3179641e8650032180b4&amp;#39;, u&amp;#39;MacAddress&amp;#39;: u&amp;#39;02:42:ac:11:00:03&amp;#39;, u&amp;#39;GlobalIPv6PrefixLen&amp;#39;: 0, u&amp;#39;Links&amp;#39;: None, u&amp;#39;GlobalIPv6Address&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;IPv6Gateway&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;DriverOpts&amp;#39;: None, u&amp;#39;IPAMConfig&amp;#39;: None, u&amp;#39;EndpointID&amp;#39;: u&amp;#39;06443f233bfac60c83c9835172c9d076a9df406bd84a350e1e713fd274caf5d3&amp;#39;, u&amp;#39;IPPrefixLen&amp;#39;: 16, u&amp;#39;IPAddress&amp;#39;: u&amp;#39;172.17.0.3&amp;#39;, u&amp;#39;Gateway&amp;#39;: u&amp;#39;172.17.0.1&amp;#39;, u&amp;#39;Aliases&amp;#39;: None}}}, u&amp;#39;HostConfig&amp;#39;: {u&amp;#39;NetworkMode&amp;#39;: u&amp;#39;default&amp;#39;}, u&amp;#39;ImageID&amp;#39;: u&amp;#39;sha256:e1ddd7948a1c31709a23cc5b7dfe96e55fc364f90e1cebcde0773a1b5a30dcda&amp;#39;, u&amp;#39;State&amp;#39;: u&amp;#39;running&amp;#39;, u&amp;#39;Command&amp;#39;: u&amp;#39;/bin/sh&amp;#39;, u&amp;#39;Names&amp;#39;: [u&amp;#39;/cranky_lichterman&amp;#39;], u&amp;#39;Mounts&amp;#39;: [], u&amp;#39;Id&amp;#39;: u&amp;#39;ededc6515049f2d13b8ee79df0729bf9f8f4d92940e6012c4f1e23ccc055c0f7&amp;#39;, u&amp;#39;Ports&amp;#39;: []}, {u&amp;#39;Status&amp;#39;: u&amp;#39;Up About a minute&amp;#39;, u&amp;#39;Created&amp;#39;: 1536673521, u&amp;#39;Image&amp;#39;: u&amp;#39;busybox&amp;#39;, u&amp;#39;Labels&amp;#39;: {}, u&amp;#39;NetworkSettings&amp;#39;: {u&amp;#39;Networks&amp;#39;: {u&amp;#39;bridge&amp;#39;: {u&amp;#39;NetworkID&amp;#39;: u&amp;#39;754e02dfae9aa61b96e78ca6dfa743f121177c2985cd3179641e8650032180b4&amp;#39;, u&amp;#39;MacAddress&amp;#39;: u&amp;#39;02:42:ac:11:00:02&amp;#39;, u&amp;#39;GlobalIPv6PrefixLen&amp;#39;: 0, u&amp;#39;Links&amp;#39;: None, u&amp;#39;GlobalIPv6Address&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;IPv6Gateway&amp;#39;: u&amp;#39;&amp;#39;, u&amp;#39;DriverOpts&amp;#39;: None, u&amp;#39;IPAMConfig&amp;#39;: None, u&amp;#39;EndpointID&amp;#39;: u&amp;#39;2a3d90402db5b9c26583a5bb4bad5c4561fb263cd2858d0e01774ab7fa5cc336&amp;#39;, u&amp;#39;IPPrefixLen&amp;#39;: 16, u&amp;#39;IPAddress&amp;#39;: u&amp;#39;172.17.0.2&amp;#39;, u&amp;#39;Gateway&amp;#39;: u&amp;#39;172.17.0.1&amp;#39;, u&amp;#39;Aliases&amp;#39;: None}}}, u&amp;#39;HostConfig&amp;#39;: {u&amp;#39;NetworkMode&amp;#39;: u&amp;#39;default&amp;#39;}, u&amp;#39;ImageID&amp;#39;: u&amp;#39;sha256:e1ddd7948a1c31709a23cc5b7dfe96e55fc364f90e1cebcde0773a1b5a30dcda&amp;#39;, u&amp;#39;State&amp;#39;: u&amp;#39;running&amp;#39;, u&amp;#39;Command&amp;#39;: u&amp;#39;/bin/sh&amp;#39;, u&amp;#39;Names&amp;#39;: [u&amp;#39;/loving_wright&amp;#39;], u&amp;#39;Mounts&amp;#39;: [], u&amp;#39;Id&amp;#39;: u&amp;#39;6721f996af1e9d04237fef0a1cb3f50e9e564173e8ff25056cdc475e8a985de5&amp;#39;, u&amp;#39;Ports&amp;#39;: []}]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>OpenStack olso_config</title>
      <link>https://zhiweiyin318.github.io/post/olso_config/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/olso_config/</guid>
      
        <description>

&lt;h1 id=&#34;oslo&#34;&gt;oslo&lt;/h1&gt;

&lt;p&gt;oslo作为OpenStack的通用组件，在每一个项目中都有用到，oslo.config主要用于命令行和配置项解析。  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考:&lt;/strong&gt;&lt;br /&gt;
* &lt;a href=&#34;https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html&#34;&gt;https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://blog.csdn.net/zhangyifei216/article/details/50434980&#34;&gt;https://blog.csdn.net/zhangyifei216/article/details/50434980&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://blog.csdn.net/hobertony_7/article/details/79206297&#34;&gt;https://blog.csdn.net/hobertony_7/article/details/79206297&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://www.programcreek.com/python/example/106149/oslo_config.cfg.ConfigOpts&#34;&gt;https://www.programcreek.com/python/example/106149/oslo_config.cfg.ConfigOpts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;使用说明&#34;&gt;使用说明&lt;/h1&gt;

&lt;p&gt;demo的代码归档：&lt;br /&gt;
&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/oslo_config&#34;&gt;https://github.com/zhiweiyin318/yzw.python.demo/tree/master/oslo_config&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#!/usr/bin/env python

# reference:
# https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html
# https://blog.csdn.net/zhangyifei216/article/details/50434980
# https://blog.csdn.net/hobertony_7/article/details/79206297
# https://www.programcreek.com/python/example/106149/oslo_config.cfg.ConfigOpts


from oslo_config import cfg
from oslo_config import types
import sys

BASE_OS_DISTRO = [&amp;#39;centos&amp;#39;, &amp;#39;rhel&amp;#39;, &amp;#39;ubuntu&amp;#39;, &amp;#39;oraclelinux&amp;#39;, &amp;#39;debian&amp;#39;]
# 命令行参数定义
_CLI_OPTS = [
    cfg.StrOpt(&amp;#39;os&amp;#39;, short=&amp;#39;o&amp;#39;, default=&amp;#39;centos&amp;#39;,
               choices=BASE_OS_DISTRO,
               help=&amp;#39;The system OS &amp;#39;
                    &amp;#39;are &amp;#39; + &amp;#39;, &amp;#39;.join(BASE_OS_DISTRO)),
    cfg.IntOpt(&amp;#39;cpu&amp;#39;, short=&amp;#39;c&amp;#39;, default=1, min=1,
               help=&amp;#39;The number of CPU&amp;#39;)
]

#配置参数定义
_CFG_OPTS = [
    cfg.StrOpt(&amp;#34;host&amp;#34;, default=&amp;#34;0.0.0.0&amp;#34;,
               help=&amp;#34;the host ip addr&amp;#34;),
    cfg.Opt(&amp;#34;port&amp;#34;, default=5999,
            type=types.Integer(1000, 6000),
            help=&amp;#34;the port number&amp;#34;)
]

_DEBUG_OPTS = [
    cfg.BoolOpt(&amp;#34;debug&amp;#34;, default=False,
                help=&amp;#34;debug config True or False&amp;#34;)
]


def main():

    # 定义configOpts实例还可以通过  conf = cfg.ConfigOpts()
    conf = cfg.CONF
    
    # 注册 命令和配置项
    conf.register_cli_opts(_CLI_OPTS)
    conf.register_opts(_DEBUG_OPTS)

    # 配置分组定义
    # DEFAULT是一个默认组，默认情况下Opt定义的选项都是属于这个组的，cfg Module给配置选项提供了组的概念，不同的组配置选项是可以重复的。
    ip_group = cfg.OptGroup(name=&amp;#34;IP&amp;#34;, title=&amp;#34;ip cfg&amp;#34;)
    conf.register_group(ip_group)

    # 待分组的配置项
    conf.register_opts(_CFG_OPTS, ip_group)

    # 获取参数，默认配置也可以通过--config-file来指定
    conf(args=sys.argv[1:],
         default_config_files=[&amp;#39;test.conf&amp;#39;])

    print &amp;#34;System OS is &amp;#34;, conf.os
    print &amp;#34;The number of CPU is &amp;#34;, conf.cpu
    print &amp;#34;The debug: &amp;#34;, conf.debug
    print &amp;#34;Host IP: &amp;#34;, conf.IP.host
    print &amp;#34;Port number: &amp;#34;, conf.IP.port


if __name__ == &amp;#39;__main__&amp;#39;:
    main()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;配置文件定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[DEFAULT]
debug = true

[IP]
host = 8.8.8.8
port = 4555&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-Cgroups-Namespace</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-cgroups-namepspace/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-cgroups-namepspace/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;容器其实就是一种沙盒技术的，沙盒就像集装箱一样，把应用装起来，应用于应用之间，有了边界，互不干扰，而且方便被搬来搬去，这就是PaaS最理想的状态。&lt;/p&gt;

&lt;p&gt;程序在操作系统的表现就是进程，容器技术的核心功能就是通过约束和修改进程的动态表现，创造出一个“边界”。Linux操作系统中，Cgroups技术是用来制造约束的手段，Namespace技术是用来修改进程视图的主要方法。&lt;/p&gt;

&lt;h2 id=&#34;隔离技术-namespace&#34;&gt;隔离技术（Namespace）&lt;/h2&gt;

&lt;p&gt;举个例子：&lt;br /&gt;
运行busybox容器，执行/bin/sh，在跑个sleep。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ docker run -it busybox /bin/sh
/ #
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    7 root      0:00 ps
/ # 
/ # sleep 100 &amp;amp;
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    9 root      0:00 sleep 100
   10 root      0:00 ps
/ # &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;宿主机上的进程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw zhiweiyin]# ps auxf
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1122  0.3  1.7 729148 66444 ?        Ssl  08:14   0:10 /usr/bin/dockerd
root      1318  0.5  0.7 574660 30976 ?        Ssl  08:14   0:16  \_ docker-containerd --config /var/run/docker/containerd/containerd.toml
root      4511  0.0  0.0   7488  3156 ?        Sl   08:58   0:00      \_ docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby
root      4529  0.0  0.0   1252   264 pts/0    Ss   08:58   0:00          \_ /bin/sh
root      4671  0.0  0.0   1232     4 pts/0    S+   09:01   0:00              \_ sleep 100&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;容器里面sh的进程号是1，但是在宿主机上进程号是4529，且是docker-containerd-shim的子进程，sleep也是类似，这就是Namespace机制，容器里面屏蔽掉了其他进程和进程号。&lt;/p&gt;

&lt;p&gt;Linux上创建线程是用clone,返回一个PID号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;int pid = clone(main_function,stack_size,SIGCHID,NULL)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当我们加上CLONE_NEWPID参数后，新创建的这个进程就会“看到”是一个全新的进程空间，在这个进程空间里PID是1。但是在主机上仍然是另外的PID号。多次执行clone会创建多个PID Namespace出来，每个进程里面PID都为1，看不到真正的宿主机上的PID，也看不到其他PID Namespace里的情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; int pid = clone(main_function,stack_size,CLONE_NEWPID|SIGCHID,NULL)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mount Namespace 用于被隔离进程只看到当前Namespace里的挂载点信息。&lt;br /&gt;
 Network Namespace 用于被隔离进程只看到当前Namespace里面的网络设备和配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这就是Linux容器实现的原理。创建容器进程时，指定了这个进程所需要启动的一组Namespace参数，这样容器就只能“看”到当前容器Namespace所限定的资源、文件、设置、状态、或者配置了，对于宿主机和其他不相干的进程都看不到了。容器其实是一种特殊的进程而已。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;虚拟机-vs-容器&#34;&gt;虚拟机 vs. 容器&lt;/h2&gt;

&lt;p&gt;先看两张图：&lt;br /&gt;
&lt;img src=&#34;https://zhiweiyin318.github.io/images/VM-Docker.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;左边是虚拟机的工作原理，Hypervisor的软件通过硬件的虚拟化功能，模拟出了运行一个操作系统所以需要的各种硬件，然后在模拟的硬件上按照一个操作系统 Guest OS，软件进程跑在这个Guest OS里，也就只能看到这个OS里面的文件和目录，以及虚拟设备。所以虚拟机也能隔离作用，但是开销太大，太重了，一个最小的CentOS KVM虚机启动后差不多需要100-200M内存，所有对资源的使用都得经过序集合软件，又是一层损耗。&lt;/p&gt;

&lt;p&gt;右边是容器的工作原理，Docker的位置是个应用一个级别的，和宿主机上其他应用进程是相同级别的，由宿主机统一管理，只不过被隔离的进程，额外设置了Namespace参数，Docker扮演的角色是辅助和管理，和Hypervisor完全不同。容器相对于虚机机来说几乎无损耗，也无需单独的Guest OS。但是容器也有弊端，所有容器之间隔离的不彻底，所有容器共用操作系统内核，内核有很多资源是不能被Namespace化的，比如时间。虚机机里面就可以随便这套了。所有应用容器化后什么可以做什么不可以做是需要考虑的一个问题，特别是对系统调用的使用上。&lt;/p&gt;

&lt;h2 id=&#34;资源限制技术-cgroups&#34;&gt;资源限制技术 Cgroups&lt;/h2&gt;

&lt;p&gt;通过Namespace技术虽然实现了容器的资源隔离，但是这个进程还是在宿主机上跑的，和其他进程共享CPU和内存的，有可能把宿主机上的CPU和内存吃完，Cgroups就是用来对进程设置资源限制的主要功能。&lt;/p&gt;

&lt;p&gt;Linux Cgroups 全称 Linux Control Group，限制一个进程使用的资源上限，包括CPU，内存，磁盘，网络带宽等。还可以对进程进行优先级设置，审计，将进程挂起和恢复等操作。&lt;/p&gt;

&lt;p&gt;Cgroups 给用户暴露出来的操作接口是文件系统，在/sys/fs/cgroup路径下，包括了各种限制资源类。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw ~]# mount -t cgroup
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)
[root@yzw cgroup]# ll /sys/fs/cgroup/
total 0
drwxr-xr-x. 5 root root  0 Sep 10 22:48 blkio
lrwxrwxrwx. 1 root root 11 Sep 10 22:48 cpu -&amp;gt; cpu,cpuacct
lrwxrwxrwx. 1 root root 11 Sep 10 22:48 cpuacct -&amp;gt; cpu,cpuacct
drwxr-xr-x. 5 root root  0 Sep 10 22:48 cpu,cpuacct
drwxr-xr-x. 3 root root  0 Sep 10 22:48 cpuset
drwxr-xr-x. 5 root root  0 Sep 10 22:48 devices
drwxr-xr-x. 3 root root  0 Sep 10 22:48 freezer
drwxr-xr-x. 3 root root  0 Sep 10 22:48 hugetlb
drwxr-xr-x. 5 root root  0 Sep 10 22:48 memory
lrwxrwxrwx. 1 root root 16 Sep 10 22:48 net_cls -&amp;gt; net_cls,net_prio
drwxr-xr-x. 3 root root  0 Sep 10 22:48 net_cls,net_prio
lrwxrwxrwx. 1 root root 16 Sep 10 22:48 net_prio -&amp;gt; net_cls,net_prio
drwxr-xr-x. 3 root root  0 Sep 10 22:48 perf_event
drwxr-xr-x. 5 root root  0 Sep 10 22:48 pids
drwxr-xr-x. 5 root root  0 Sep 10 22:48 systemd&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;举个例子：&lt;br /&gt;
cfs_period和cfs_quota组合使用，限制进程在cfs_period的一段时间内，只能被分到总量为cfs_quota的CPU时间。&lt;br /&gt;
在/sys/fs/cgroup/cpu目录下创建container文件夹，系统自动创建了一堆资源限制文件。这个目录就成为一个“控制组”。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw cpu]# mkdir container
[root@yzw cpu]# ls container/
cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们后台执行个死循环,top发现CPU1被吃完了，container控制组quota没有限制，period是100ms（100000us）。&lt;br /&gt;
我们修改配置，quota写入20ms就是说100ms该控制组的进程只能使用20ms的CPU，这个进程只使用20%的CPU带宽，我们把限制的进程PID写入该控制组。&lt;br /&gt;
再次top发现CPU1的使用率降下来了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw cpu]# while :; do : ;done &amp;amp;
[1] 3592

[root@yzw cpu]# top
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st

[root@yzw container]# cat cpu.cfs_period_us 
100000
[root@yzw container]# cat cpu.cfs_quota_us 
-1

[root@yzw container]# echo 20000 &amp;gt; cpu.cfs_quota_us 
[root@yzw container]# echo 3592 &amp;gt; tasks 
[root@yzw container]# top
%Cpu1  : 17.4 us,  0.0 sy,  0.0 ni, 82.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Cgroups的设计比较简单粗暴，就是一个子系统目录加上一组资源限制文件的组合。Docker等容器项目来说就是在各个子系统下，为每个容器创建一个控制组（就是新建个目录），然后启动容器进程后，把容器进程的PID写入对应控制组的tasks文件中就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;[root@yzw docker]# docker run -it --cpu-period=100000 --cpu-quota=20000 centos:7 /bin/bash
[root@90c9fd20daf8 /]# 

[root@yzw ~]# cd /sys/fs/cgroup/cpu/docker/90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd/
[root@yzw 90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd]# cat cpu.cfs_quota_us 
20000
[root@yzw 90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd]# cat cpu.cfs_period_us 
100000
[root@yzw 90c9fd20daf8f4f9ad384d349d37ca1542490d78daf4e3fe6b79f3ad6d7179bd]# &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;容器就是一个启动了多个Namespace的应用进程，这个进程能够使用的资源量，通过Cgroups配置限制。
&lt;strong&gt;容器技术中一个非常重要的概念，容器是一个单进程模型。&lt;/strong&gt; 用户的应用进程就是容器里面PID=1的进程，其他后续创建的进程都是这个进程的子进程，意味着你没法运行两个不同的应用，除非找到一个公共的PID=1的程序来充当两个不同程序的父进程。好多人使用systemd或者superviord来充当容器的启动进程。 容器的设计希望容器和进程应用同生命周期，对后续编排很重要，如果容器是正常运行的，里面的应用挂了，处理起来就很麻烦。&lt;/p&gt;

&lt;h1 id=&#34;issue&#34;&gt;issue&lt;/h1&gt;

&lt;p&gt;跟Namespace一样，Cgroups也有缺陷，提起最多的就是/proc文件系统的问题。/proc存储的是内核运行状态的一系列特殊文件，用户可以访问这些文件查看当前运行的进程的状态，比如CPU使用情况，内存使用情况，这些是top的主要数据来源。但是/proc不了解Cgroups的存在，就是容器里面读取的CPU核数，内存状态其实是宿主机的，会带来很多困惑和风险。&lt;br /&gt;
lxcfs可以增强docker资源的可见性，可解决这个问题。做法是把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。kubernetes环境下，也能用，以ds 方式运行 lxcfs ，自动给容器注入争取的 proc 信息。&lt;/p&gt;

&lt;p&gt;/proc文件系统的问题我好像遇到过这个坑..当时在容器上运行的java应用，由于当时jvm参数没正确配置上，就用默认的，而容器设置的内存为4g，最后oom了，当时用命令查看容器的内存占用情况，竟然发现内存竟然有60多g。 那应该显示的是宿主机的内存了，jvm按照宿主机内存大小分配的默认内存应该大于4g 所以还没full gc 就oom了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-History</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-history/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-history/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;我是2017年误打误撞的掉进了云计算这个坑里，上来就是Docker，Mesos，Kubernetes，现在主要从事Kubernetes相关工作。这两年对云计算的学习都是碎片化的，没有系统的学习思考过，碰巧看到有人推荐极客时间专栏《深入剖析Kubernetes》，就花钱订阅了，现在出去吃顿饭稍微吃爽也得一两张毛爷爷，几十块的课程舍不得就说不过去，看看课程目录想着应该干货不多，但是看来前面几节内容，深深的被吸引了。作者张磊，在云计算这个坑里摸爬滚打了数年，把这个行当的发展娓娓道来，侃侃而谈，深入浅出的介绍了为啥Docker，Kubernetes突然火起来了，把Docker，Kubernetes的技术也通俗易懂的语言在讲，最主要的是系统的在讲，这个正是我知识体系缺少的。&lt;br /&gt;
这里就开始记录我学习的一些笔记。&lt;br /&gt;
课程地址：&lt;a href=&#34;https://time.geekbang.org/column/article/14254&#34;&gt;https://time.geekbang.org/column/article/14254&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;

&lt;p&gt;这些年的教育导致凡事学个啥都想着先找个定义，云计算的定义相信这些年随着时间和技术的变革，不停的在发生着变化，我试着找了找定义：&lt;/p&gt;

&lt;h2 id=&#34;云计算&#34;&gt;云计算&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;“云计算的本质是一种服务提供模型，通过这种模型可以随时、随地、按需地通过网络访问共享资源池的资源，这个资源池的内容包括计算资源、网络资源、存储资源等，这些资源能够被动态地分配和调整，在不同用户之间灵活的划分。凡是符合这些特征的IT服务都可以成为云计算服务。&lt;br /&gt;
——Security Guidance for Critical Areas of Focus In Cloud Computing V3.0”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NIST(U.S. National Institute of Standards and Technology)提出了一个定义云计算的标准“NIST Working Definition of Cloud Computing/NIST 800-145”，这个标准中提出云计算具备的五个基本要素：&lt;strong&gt;通过网络分发服务、自助服务、可衡量的服务、资源的灵活调度、资源池化&lt;/strong&gt;。另外，这个标准还提到，云计算按照服务类型可以分为 &lt;strong&gt;IaaS、PaaS、SaaS&lt;/strong&gt; 三类，按照部署模式分为 &lt;strong&gt;公有云、私有云、混合云和社区云&lt;/strong&gt; 四种。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/IaaS-PaaS-SaaS.PNG&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iaas-infrastructure-as-a-service&#34;&gt;IaaS (Infrastructure as a service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Infrastructure as a service (IaaS)  is a cloud computing offering in which a vendor provides users access to computing resources such as servers, storage and networking. Organizations use their own platforms and applications within a service provider’s infrastructure.&lt;br /&gt;
Examples: DigitalOcean, Linode, Rackspace, Amazon Web Services (AWS), Microsoft Azure, Google Compute Engine (GCE), 阿里云，腾讯云&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;IaaS 要解决什么问题？&lt;br /&gt;
1. 用户不用购买硬件设备了，直接按需购买资源就行了。&lt;br /&gt;
2. 用户可以按需扩容缩容自己所需要的资源。 (业务忙时多申请几个机子，业务不忙了少几个机子，反正时按资源收费的。)&lt;br /&gt;
3. 不用安排专人维护硬件设备了，也不会有什么机房断电，设备单点故障了影响业务。&lt;br /&gt;
4. 用起来让你感觉跟物理机没啥区别。&lt;/p&gt;

&lt;h3 id=&#34;paas-platform-as-a-service&#34;&gt;PaaS (Platform as a Service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Platform as a service (PaaS) is a cloud computing offering that provides users with a cloud environment in which they can develop, manage and deliver applications. In addition to storage and other computing resources, users are able to use a suite of prebuilt tools to develop, customize and test their own applications.&lt;br /&gt;
Examples: AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine, Apache Stratos, OpenShift&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PaaS 要解决什么问题？&lt;br /&gt;
云上有了资源（虚拟机）后，提供给用户一套开发，测试，打包，发布，管理和运维的平台，让你很方便的在IaaS上搞你的业务，不用care底层资源 。&lt;/p&gt;

&lt;h3 id=&#34;saas-software-as-a-service&#34;&gt;SaaS (Software as a Service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Software as a service (SaaS)  is a cloud computing offering that provides users with access to a vendor’s cloud-based software. Users do not install applications on their local devices. Instead, the applications reside on a remote cloud network accessed through the web or an API. Through the application, users can store and analyze data and collaborate on projects.&lt;br /&gt;
Examples: Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SaaS 要解决什么问题？&lt;br /&gt;
这个我也没接触过，理解就是所有软件都在云上了，你只要类似打开浏览器的东东就可以用各种软件，不用再安装了，你的数据啥的都在云上了。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考:&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/cloud/learn/iaas-paas-saas&#34;&gt;https://www.ibm.com/cloud/learn/iaas-paas-saas&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.computenext.com/blog/when-to-use-saas-paas-and-iaas/&#34;&gt;https://www.computenext.com/blog/when-to-use-saas-paas-and-iaas/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Platform_as_a_service&#34;&gt;https://en.wikipedia.org/wiki/Platform_as_a_service&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&#34;&gt;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;历史&#34;&gt;历史&lt;/h1&gt;

&lt;h2 id=&#34;docker-的出现&#34;&gt;Docker 的出现&lt;/h2&gt;

&lt;p&gt;2013年那会云计算不再时虚无缥缈的概念了，已经商业化比较成熟了，AWS如日中天，Openstack火的一塌糊涂，以Cloud Foundry为代表的开源PaaS项目度过了最艰难的的概念普及和用户教育阶段，吸引力一堆知名技术厂商的投入，开始了以开源PaaS为核心构建平台层服务能力的变革，PaaS的时代来临了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Cloud Foundry is an open source, multi cloud application platform as a service (PaaS) governed by the Cloud Foundry Foundation, a 501&amp;copy;(6) organization.The software was originally developed by VMware and then transferred to Pivotal Software, a joint venture by EMC, VMware and General Electric.&lt;br /&gt;
&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Cloud_Foundry&#34;&gt;https://en.wikipedia.org/wiki/Cloud_Foundry&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker公司那会还叫dotCloud也是PaaS热潮的中一个小公司，主打产品与主流的Cloud Foundry社区脱节，长期无人问津。&lt;br /&gt;
* 2013年3月，dotCloud公司推出自己的容器开源项目Docker。&lt;br /&gt;
* 2013年10月，dotCloud公司正式转换业务核心并将自身重新定名为Docker。到这时，Docker已经拥有超过200名贡献者，其中九成以上来自公司之外。Docker的下载量超过10万次，包括eBay在内的众多企业开始对其加以利用，相关社区也在全球范围内快速建立。短短几个月Cloud Foundry和其他PaaS社区还没来得及成为它的对手就已经出局了。  dotCloud公司改名为Docker公司。&lt;/p&gt;

&lt;h2 id=&#34;遇到和解决了什么问题&#34;&gt;遇到和解决了什么问题&lt;/h2&gt;

&lt;h3 id=&#34;cloud-foundry的paas解决了什么问题&#34;&gt;Cloud Foundry的PaaS解决了什么问题&lt;/h3&gt;

&lt;p&gt;当时大家租赁AWS或者Openstack的虚机机，还是像以前管理物理机那样，通过脚本或者手动的方式在虚拟机上部署应用。但是云上的资源环境和物理机还是不一致的，当时的云计算服务比的是谁能更好的模拟本地服务器环境，能带来更好的“云上”体验。&lt;/p&gt;

&lt;p&gt;PaaS的出现就是解决这个问题的一个最佳方案。举个例子，虚拟机建好后，运维人员只需在这些机子上部署一个Cloud Foundry项目，然后执行一条命令就可以把本地的应用部署到云上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cf push &amp;#34;我的应用&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Cloud Foundry这样的PaaS项目最核心的组件就是打包和分发机制。为每种语言都定义一种打包机制，push时相当于把可执行文件和启动脚本打包到一个压缩包里面，上传到云上的存储种，然后调度一个可用的虚机，这个虚机的agent下载应用启动运行。&lt;/p&gt;

&lt;p&gt;由于同一个虚机会运行不同的应用，Cloud Foundry调用系统的Cgroups和Namespace机制为每一个应用单独创建一个叫“沙盒”的隔离环境，在“沙盒”里启动这些应用进程，实现一个虚机里面同时运行不同的应用，互不干涉。沙盒也就是后来的容器。&lt;/p&gt;

&lt;h3 id=&#34;docker解决了什么问题&#34;&gt;Docker解决了什么问题&lt;/h3&gt;

&lt;p&gt;Docker发布后，技术上跟Cloud Foundry的沙盒没有啥本质区别，但是最大不同就是容器的镜像。&lt;/p&gt;

&lt;p&gt;问题出在Cloud Foundry的一键部署很方便，但是打包却比较麻烦，一旦用上PaaS，用户必须为每一种语言，框架，甚至版本维护一给打好的包，而这个打包过程，除了可执行文件和启动脚本外，需要修改好多配置才能跑起来，这个修改没有经验可用借鉴，全凭试错尝试。&lt;/p&gt;

&lt;p&gt;Docker 镜像恰巧解决了这个问题。这个镜像就是一个压缩包，直接由一整套完整的操作系统的文件和目录组成的，有应用所需要的完整的依赖环境，内容可用和测试环境完全一样，所有不需要任何配置和修改直接保证了本地环境和云端环境的高读一致。拿着这个压缩包，使用某种技术创建一个“沙盒”环境，在沙盒里面解压缩，运行程序就可以了。&lt;strong&gt;这就是Docker的精髓。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PaaS最核心的打包系统一下子无用武之地了，抓狂的打包过程消失了。&lt;/p&gt;

&lt;p&gt;提供一个下载好的操作系统文件和目录，制作一个压缩包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;docker build &amp;#34;镜像&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Docker创建一个“沙盒”，解压压缩包，运行自己的应用。这个沙盒也是通过Cgroups和Namespace技术来实现环境隔离的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;docker run &amp;#34;镜像&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;docker公司是怎么把docker搞火的&#34;&gt;Docker公司是怎么把Docker搞火的&lt;/h3&gt;

&lt;p&gt;Docker公司的重要战略是“坚持把开发者群体放在至高无上的位置”，所以一开始Docker的推广是以开发者为主导的，简单的UI，有趣的demo，无论是你懂不懂后端，很简单就可以发布自己的应用，PaaS的受益者和最终用户，肯定都是开发者。&lt;br /&gt;
Docker只是个开源项目的名称，dotCloud公司将自己的公司名字改为了Docker，鲸鱼的Logo也成为了商业商标。&lt;/p&gt;

&lt;h3 id=&#34;docker为啥发布swarm项目&#34;&gt;Docker为啥发布Swarm项目&lt;/h3&gt;

&lt;p&gt;Docker项目的出现，让PaaS的定义由之前的CLoud Foundry描述的那样变成了一个由Docker镜像为标准的全新的概念。&lt;/p&gt;

&lt;p&gt;Docker虽然解决了打包的问题，还不能叫做PaaS，因为PaaS的另一个重要功能是大规模部署。Docker在2014年的DockerCon上推出了自己的容器集群管理项目Swarm，预示着Docker公司想重新定义PaaS的愿望。&lt;/p&gt;

&lt;p&gt;Docker的快速崛起后，CoreOS公司快速将容器融入自己的PaaS解决方案中，是当时DOcker项目的第二重要力量，但是随着Docker公司战略和对Docker项目的定位的改变，Docker公司想提供更多平台层的能力，向PaaS项目发展。显然和CoreOS的核心产品和战略冲突，2014年底CoreOS退出Docker项目，发布了自己Rocket(rkt)容器。&lt;/p&gt;

&lt;p&gt;CoreOS是一系列开源项目的组合，包括Container Linux操作系统，Fleet作业调度工具，systemd进程管理，rkt容器。Swarm则是以一个完整的整体来对外管理集群，最大亮点是完全使用Docker项目的API来完成管理集群，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#单机Docker项目：
docker run “我的镜像”

#集群Docker项目：
docker run -H “Swarm集群IP” “我的镜像”&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;编排概念的出现&#34;&gt;编排概念的出现&lt;/h3&gt;

&lt;p&gt;Docker的崛起，2014-2015年催生了一个繁荣的Docker生态，Docker收购了Fig项目，后面改名为Compose项目。&lt;/p&gt;

&lt;p&gt;编排在云计算领域是指通过工具或者配置来完成一组虚拟机以及相关资源的定义，配置，创建，删除等工作。&lt;/p&gt;

&lt;p&gt;Fig项目首次提出了容器编排概念“Container Orchestration”。通过执行一条简单命令，将一个配置文件里面定义的不同的容器，按照他们的指定关联关系创建起来。&lt;/p&gt;

&lt;h3 id=&#34;mesos的转型&#34;&gt;Mesos的转型&lt;/h3&gt;

&lt;p&gt;Mesos昨晚Berkeley主导的大数据套件之一，是当时大数据最受欢迎的资源管理项目，跟Yarn项目杀的难舍难分。大数据项目关注的是计算密集型离线业务，对应用打包和集群扩容托管没啥强烈需求，Hadoop，Spark等项目到现在也没有在容器上投入更大赌注。&lt;/p&gt;

&lt;p&gt;Mesos的两层调度系统，天然可以支持PaaS业务，Mesos+Marathon项目很快成了Docker Swarm的有力竞争对手。Mesos拥有超大规模集群管理的经验，也有大规模生产环境在使用了，比如eBa，。Marathon提供了应用托管和负载均功能。Mesos公司提出了DC/OS的口号和产品，旨在使用户能够像管理一台机器一样管理一个万级别的物理集群，并且使用Docker容器在这个集群中自由部署应用。&lt;/p&gt;

&lt;h3 id=&#34;kubernetes的诞生&#34;&gt;Kubernetes的诞生&lt;/h3&gt;

&lt;p&gt;这个时候CoreOS完全被Docker压制，RedHat作为Docker项目早期重要贡献者也因为Docker公司的平台战略不满退出，OpenSift还勉强支撑，Mesos和Swarm是主要竞争对手。2014年6月Google发力，发布了Kubernetes项目，这个项目不仅挽救了CoreOS和RedHat，同时改变了整个容器市场的格局。&lt;/p&gt;

&lt;p&gt;2014-2015年，整个容器社区热闹非凡，大量围绕Docker项目的网络，存储，监控，CI/CD，UI项目纷纷出台，也涌现出了Rancher，Tutun开源和商业上都取得成功的创业公司。Docker公司发布了Compose，Swarm和Machine三件套，Docker公司想从开源成功走向商业成功。&lt;/p&gt;

&lt;p&gt;Google的容器项目也招架住Docker，Google本想提议关停自己容器项目，和Docker共同推出了一个中立的容器运行时库（container runtime）作为Docker项目的核心依赖。DOcker没有同意削弱自己地位的建议，推出了自己的容器运行时库Libcontainer。由于比较匆忙，代码可读性差，可维护不强，被社区长期诟病。&lt;/p&gt;

&lt;p&gt;2015年6月，各个玩家开始切割Docker项目的话语权，手段也很经典。由Docker牵头，CoreOS，Google，RedHat等公司宣布，Docker将LibContainer捐出，改名RunC项目，交由一个完全中立的基金会管理，然后以RunC为依据，共同指定一套容器和镜像的标准和规范。&lt;/p&gt;

&lt;p&gt;这套标准规范就是OCI （open Container Initiative）。提出将容器运行和镜像的实现从Dokcer项目完全剥离出来，一方面改善了Docker在这一块一家独大的现状，另一方面各个玩家可以不依赖Docker项目构建各自的平台能力。这是一群玩家根据各自利益干涉的一个妥协结果。Docker公司虽然时OCI的发起者和创始成员，但是很少在标准指定上扮演关键角色，也没有动力去推进这些所谓的标准，这就是为啥OCI组织效率持续低下的根本原因。&lt;/p&gt;

&lt;p&gt;Docker不担心OCI的威胁，是因为Docker项目的容器生态的事实标准，社区足够庞大。但是斗争转移到容器之上的平台层，即PaaS，Docker公司就没有多大优势了。这个领域Google和RedHat有着深厚的技术积累，CoreOS这样的创业公司也有像Etcd这样的开源基础设施项目，Docker只有一个Swarm。&lt;/p&gt;

&lt;p&gt;Google，RedHat等开源基础设施玩家，共同牵头发起了一个CNCF（Cloud Native Computing Foundation）的基金会。目的就是希望以Kubernetes项目为基础，建立一个由开源基础设施厂商主导的，按照独立基金会运行的平台级社区，对抗Docker公司为核心的容器商业生态。&lt;/p&gt;

&lt;p&gt;Kubernetes的竞争对手为Swarm和Mesos，Swarm擅长和Docker生态无缝集成，Mesos擅长大规模集群的调度和管理。Kubernetes另开辟径，将Borg和Omega系统的内部特性落到Kubernetes项目上，就是Pod，Sidecar等超前的功能和设计模式。这些都是Google公司在这个领域多年的经验积累沉淀。RedHat和Google达成联盟，为这个项目投入了很多贡献，保证了自己的影响力。&lt;/p&gt;

&lt;p&gt;Mesos的Apache社区比较封闭，虽然成熟，但是缺乏创新，Swarm虽然强调Docker Native，但是杀伤力不大。Kubernetes项目耳目一新的设计理念和号召力，构建出了一个与众不同的容器编排和管理生态，迅速崛起，Github社区各项指标一骑绝尘，Swarm远远被甩身后。&lt;/p&gt;

&lt;p&gt;CNCF社区添加了像Prometheus，Fluentd，CNI等一系列容器知名生态工具和项目，大量的公司和创业团队开始专门针对CNCF社区而非Docker公司制定推广策略。&lt;/p&gt;

&lt;p&gt;Docker为了应对竞争，2016年宣布放弃Swarm项目，将容器编排和集群管理功能内置到Docker项目中，虽然可以使得Docker项目的边界扩大到一个完整的PaaS项目范畴，但是增加了技术复杂度和维护难度。&lt;/p&gt;

&lt;p&gt;Kubernetes反其道行之，在社区推进“民主化”架构，从API到容器运行时的每一层，都为开发者提供可扩展的插件机制，鼓励通过代码方式介入到Kubernetes的每一个阶段。催生了大量基于Kubernetes API和扩展接口的二次创业工作，社区在2016年之后得到了空前的发展。不同于之前局限于打包发布的PaaS化路线，这一次是围绕Kubernetes项目为核心的百花争鸣。Docker公司不得不面对这次豪赌的失败，开始放弃开源社区，专注于自己的商业化转型。&lt;/p&gt;

&lt;p&gt;2017年开始，Docker公司将DOcker项目的容器运行时部分Containerd捐赠给了CNCF社区，标志着Docker项目完全升级为一个PaaS平台，Docker宣布将Docker项目改名为Moby，交给社区自行维护。&lt;/p&gt;

&lt;p&gt;2017年10月，Docker宣布在自己主打产品Docker企业版内置Kubernetes项目。&lt;/p&gt;

&lt;p&gt;2018年1月20日，RedHat收购CoreOS。&lt;/p&gt;

&lt;p&gt;2018年3月28日，Docker公司的CTO Solomon Hykes 宣布辞职。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;后面这段历史原作者将的酣畅淋漓，基本照搬过来的。大家自行体会这几年这个领域的风云变化和各大玩家的角逐。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器技术兴起源于PaaS技术的普及&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker项目通过“容器镜像”，解决了应用打包这个根本性难题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器本身没有价值，有价值的是“容器编排”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>golang rand生成随机数</title>
      <link>https://zhiweiyin318.github.io/post/golang-rand%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/golang-rand%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      
        <description>

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;math/rand package实现了伪随机数字生成器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;随机数字是通过Source生成的，rand.Seed会初始化默认全局的Source，如果不调用rand.Seed就会使用默认的Source。所生成的随机数字是固定顺序生成的，每次运行程序如果seed相同的话，生成随机数是相同的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;默认的Source是线程安全的，自己通过New生成的不是。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;参考： &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34;&gt;https://golang.org/pkg/math/rand/&lt;/a&gt;&lt;br /&gt;
Package rand implements pseudo-random number generators.&lt;/p&gt;

&lt;p&gt;Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;源码：&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.go.demo/tree/master/rand&#34;&gt;https://github.com/zhiweiyin318/yzw.go.demo/tree/master/rand&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;rand1 使用默认的Seed和Source，每次执行main，获取的随机数字都是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand1() {
	fmt.Println(&amp;#34;rand1 test ######## rand.xx ######## &amp;#34;)
	fmt.Println(&amp;#34;rand int : &amp;#34;, rand.Int(), rand.Int31())
	// random int in [0,100)
	fmt.Println(&amp;#34;random int in [0,100) : &amp;#34;, rand.Intn(100))
	// random int in [-50,50)
	fmt.Println(&amp;#34;random int in [-50,50) : &amp;#34;, rand.Intn(100)-50)
	fmt.Println(&amp;#34;rand float : &amp;#34;, rand.Float64())
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand2 每次配置相同的Seed，则生成的随机值都是相同的。下面循环5次的随机数字都是一样的，因为Seed重装了Source，都是从头开始生成随机数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand2() {
	fmt.Println(&amp;#34;rand2 test ######## generate the same random values using the same rand.Seed  ######## &amp;#34;)
	for i := 0; i &amp;lt; 5; i++ {
		rand.Seed(10)
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand3 配置不同的Seed，生成的随机值是不同的。但是同一个Seed在执行main后生成的值都是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand3(){
	fmt.Println(&amp;#34;rand2 test ######## generate the same random values using the different rand.Seed  ######## &amp;#34;)
	for i := 0; i &amp;lt; 5; i++ {
		rand.Seed((int64)(i))
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand4 使用rand.New()生成新的rand，rand.NewSource()生成新的Source。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand4() {
	fmt.Println(&amp;#34;rand4 test ######## rand.NewSource and rand.New ######## &amp;#34;)
	s := rand.New(rand.NewSource(1))
	for i := 0; i &amp;lt; 5; i++ {
		fmt.Println(&amp;#34;rand4: &amp;#34;, s.Int(), s.Intn(20), s.Float64())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand5 保证每次运行程序随机值跟上次不一样，可以通过当前实际生成Seed&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand5(){
	fmt.Println(&amp;#34;rand4 test ######## use time.Now().Unix() as seed ######## &amp;#34;)
	rand.Seed(time.Now().Unix())
	for i := 0; i &amp;lt; 5; i++ {
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand6 协程安全测试&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;待补充...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>golang的测试框架</title>
      <link>https://zhiweiyin318.github.io/post/golang%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/golang%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      
        <description>

&lt;h1 id=&#34;golang-测试框架&#34;&gt;golang 测试框架&lt;/h1&gt;

&lt;p&gt;本文主要介绍golang 测试的集中常见的框架。&lt;/p&gt;

&lt;h2 id=&#34;go-test&#34;&gt;go test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件名称位xx_test.go&lt;/li&gt;
&lt;li&gt;测试函数Testxxx(t *testing.T)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go test -v&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;goconvey&#34;&gt;GoConvey&lt;/h2&gt;

&lt;p&gt;可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性，集成go test。&lt;/p&gt;

&lt;p&gt;Write behavioral tests in your editor. Get live results in your browser.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/smartystreets/goconvey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;官网：&lt;code&gt;http://goconvey.co/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;介绍：&lt;code&gt;https://www.jianshu.com/p/e3b2b1194830&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/smartystreets/goconvey &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在$GOPATH/src目录下新增了github.com子目录，该子目录里包含了GoConvey框架的库代码&lt;/li&gt;
&lt;li&gt;在$GOPATH/bin目录下新增了GoConvey框架的可执行程序goconvey&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;web显示结果，在测试目录下执行goconvoy就可以&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;testing&amp;#34;
)

func Test_ServerRun(t *testing.T) {
    Convey(&amp;#34;Test ServerRun &amp;#34;, t, func() {
        Convey(&amp;#34;Case 1 port &amp;gt; 10000:&amp;#34;, func(){
            port := 100000
            So(ServerRun(port), ShouldBeError)
        })
        Convey(&amp;#34;Case 2 port &amp;lt;= 10000:&amp;#34;, func() {
            port := 1000
            So(ServerRun(port), ShouldBeNil)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;gostub&#34;&gt;GoStub&lt;/h2&gt;

&lt;p&gt;主要用来给全局变量打桩，也可以给函数打桩，无法给方法接口打桩。
* 项目：&lt;code&gt;https://github.com/prashantv/gostub&lt;/code&gt;
* 介绍：&lt;code&gt;https://www.jianshu.com/p/70a93a9ed186&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;安装-1&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/prashantv/gostub&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-1&#34;&gt;使用&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    &amp;#34;testing&amp;#34;
    . &amp;#34;github.com/prashantv/gostub&amp;#34;
)
func Test_ServerRun_Case3(t *testing.T){
    Convey(&amp;#34;Test ServerRun &amp;#34;,t,func(){
        Convey(&amp;#34;Case 1 IP is not local IP:&amp;#34;,func(){
            stubs :=Stub(&amp;amp;localIP,&amp;#34;192.168.1.1&amp;#34;)
            defer stubs.Reset()
            So(ServerRun(8080), ShouldBeError)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;monkey&#34;&gt;Monkey&lt;/h2&gt;

&lt;p&gt;可以给函数，方法打桩&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/bouk/monkey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;官网：&lt;code&gt;https://bou.ke/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;介绍：&lt;code&gt;https://www.jianshu.com/p/2f675d5e334e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装-2&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/bouk/monkey&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-2&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;inline 函数打桩无效&lt;/li&gt;
&lt;li&gt;方法的首字母大小写，只能给首大写字母的方法打桩&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    &amp;#34;github.com/bouk/monkey&amp;#34;
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;reflect&amp;#34;
    &amp;#34;testing&amp;#34;
    &amp;#34;errors&amp;#34;
)
func Test_ServerRun_Monkey(t *testing.T) {
    Convey(&amp;#34;Test ServerRun &amp;#34;, t, func() {
        Convey(&amp;#34;Case 1 Listen failed:&amp;#34;, func() {
            defer monkey.UnpatchAll()
            monkey.Patch(Listen, func(s *server) error {
                return errors.New(&amp;#34;fake return fail&amp;#34;)
            })
            So(ServerRun(8080), ShouldBeError)
        })

        Convey(&amp;#34;Case 2 s.GetIP failed:&amp;#34;, func() {
            var s *server
            defer monkey.UnpatchAll()
            monkey.PatchInstanceMethod(reflect.TypeOf(s), &amp;#34;GetIP&amp;#34;, func(_ *server) string {
                return &amp;#34;192.168.1.1&amp;#34;
            })
            So(ServerRun(8080),ShouldBeError)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;gomock&#34;&gt;GoMock&lt;/h2&gt;

&lt;p&gt;给接口打桩&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/golang/mock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文档：&lt;code&gt;https://godoc.org/github.com/golang/mock/gomock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参考：&lt;code&gt;https://www.jianshu.com/p/f4e773a1b11f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装-3&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;mkdir $GOPATH/src/golang.org/x/
cd $GOPATH/src/golang.org/x/
git clone https://github.com/golang/net.git net 
go install net
go get github.com/golang/mock/gomock
go install github.com/golang/mock/mockgen&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-3&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;生成接口的mock文件&lt;/li&gt;
&lt;li&gt;输出目录需要提起建好&lt;/li&gt;
&lt;li&gt;gomock的代码需放在$GOPATH/src下，mockgen运行时要在这个路径下访问gomock&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;./mockgen -source=/home/yzw/go/src/examples/pkg/common/common.go &amp;gt; /home/yzw/go/src/examples/test/common/mock_common.go&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    . &amp;#34;github.com/golang/mock/gomock&amp;#34;
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;testing&amp;#34;

    &amp;#34;examples/test/common&amp;#34;
    &amp;#34;errors&amp;#34;
    &amp;#34;github.com/bouk/monkey&amp;#34;
    &amp;#34;examples/pkg/common&amp;#34;
    &amp;#34;fmt&amp;#34;
)

func Test_ClientRun_GoMock(t *testing.T) {
    Convey(&amp;#34;Test ClientRun&amp;#34;, t, func() {
        ctrl := NewController(t)
        defer ctrl.Finish()
        mockOpter := mock_common.NewMockOpter(ctrl)
        mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))

        defer monkey.UnpatchAll()
        monkey.Patch(NewClient, func() common.Opter {
            fmt.Println(&amp;#34;fake newclient&amp;#34;)
            return mockOpter
        })
        So(ClientRun(&amp;#34;ip&amp;#34;,&amp;#34;port&amp;#34;,&amp;#34;opt&amp;#34;),ShouldBeError)
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果mock的接口被调用多次，需要用Times&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;)).Times(5)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;mock的接口有先后顺序的时候，需要同After，InOder来保序&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;getCall := mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))
mockOpter.EXPECT().Post(Any()).Return(errors.New(&amp;#34;mock post error&amp;#34;)).After(getCall)
InOder(
    mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))
    mockOpter.EXPECT().Post(Any()).Return(errors.New(&amp;#34;mock post error&amp;#34;))
)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://zhiweiyin318.github.io/post/hugo/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/hugo/</guid>
      
        <description>

&lt;h2 id=&#34;为啥搞blog&#34;&gt;为啥搞blog&lt;/h2&gt;

&lt;p&gt;之前在sina写过复盘日记，后来也没坚持下来；之前在github上用其他框架搭过blog，太繁琐了，也放弃了。&lt;/p&gt;

&lt;p&gt;最近在有道云上记笔记，开始用markdown，觉得很方便，正好看到Hugo这个go写的静态网页框架，天然对go的好感，索性就搞一把。&lt;/p&gt;

&lt;p&gt;以后把笔记就记这了，走哪都方便查看。&lt;/p&gt;

&lt;h2 id=&#34;怎么用hugo-github搭建blog&#34;&gt;怎么用hugo+github搭建blog&lt;/h2&gt;

&lt;h3 id=&#34;下载hugo可执行文件-二进制文件&#34;&gt;下载hugo可执行文件（二进制文件）&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;下载地址： &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;https://github.com/gohugoio/hugo/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;创建框架&#34;&gt;创建框架&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; ./hugo.exe new site blog     &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;下载更换主题&#34;&gt;下载更换主题&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cd blog
git clone https://github.com/xianmin/hugo-theme-jane.git themes/jane&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;主题下载地址：&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;修改主题&#34;&gt;修改主题&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; cp themes/jane/exampleSite/config.toml ./&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;特别是config.toml文件&lt;/p&gt;

&lt;h3 id=&#34;新建博文&#34;&gt;新建博文&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe new start.md&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;本地测试&#34;&gt;本地测试&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe server&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 可以查看效果&lt;/p&gt;

&lt;h3 id=&#34;发布&#34;&gt;发布&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;生成public文件夹，将该文件夹所有文件push到username.github.io仓库。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我之前以为要把整个目录上传，发现不现实，最后才搞明白是把public上传就可以了，但是每次生成发布比较麻烦，准备搞个脚本弄哈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;issue&#34;&gt;issue&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;怎么贴图&lt;br /&gt;
图片放到/static下，md里里面直接引用相对路径，比如我把图片放到static/images下了，直接引用/images/xxx就可以了。发布的时候会拷贝过去。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nanshu.wang/post/2015-01-31/&#34;&gt;http://nanshu.wang/post/2015-01-31/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&#34;&gt;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
  </channel>
</rss>