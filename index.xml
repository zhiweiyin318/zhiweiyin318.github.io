<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zhiwei Yin&#39;s Blog</title>
    <link>https://zhiweiyin318.github.io/</link>
    <description>Recent content on Zhiwei Yin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 31 Jul 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://zhiweiyin318.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://zhiweiyin318.github.io/about/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/about/</guid>
      
        <description>&lt;p&gt;Hi,我是殷智伟。&lt;br /&gt;
这里主要自己的工作学习生活笔记。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>《深入剖析Kubernetes》-学习笔记-历史</title>
      <link>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%86%E5%8F%B2/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%86%E5%8F%B2/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;我是2017年误打误撞的掉进了云计算这个坑里，上来就是Docker，Mesos，Kubernetes，现在主要从事Kubernetes相关工作。这两年对云计算的学习都是碎片化的，没有系统的学习思考过，碰巧看到有人推荐极客时间专栏《深入剖析Kubernetes》，就花钱订阅了，现在出去吃顿饭稍微吃爽也得一两张毛爷爷，几十块的课程舍不得就说不过去，看看课程目录想着应该干货不多，但是看来前面几节内容，深深的被吸引了。作者张磊，在云计算这个坑里摸爬滚打了数年，把这个行当的发展娓娓道来，侃侃而谈，深入浅出的介绍了为啥Docker，Kubernetes突然火起来了，把Docker，Kubernetes的技术也通俗易懂的语言在讲，最主要的是系统的在讲，这个正是我知识体系缺少的。&lt;br /&gt;
这里就开始记录我学习的一些笔记。&lt;br /&gt;
课程地址：&lt;a href=&#34;https://time.geekbang.org/column/article/14254&#34;&gt;https://time.geekbang.org/column/article/14254&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;

&lt;p&gt;这些年的教育导致凡事学个啥都想着先找个定义，云计算的定义相信这些年随着时间和技术的变革，不停的在发生着变化，我试着找了找定义：&lt;/p&gt;

&lt;h2 id=&#34;云计算&#34;&gt;云计算&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;“云计算的本质是一种服务提供模型，通过这种模型可以随时、随地、按需地通过网络访问共享资源池的资源，这个资源池的内容包括计算资源、网络资源、存储资源等，这些资源能够被动态地分配和调整，在不同用户之间灵活的划分。凡是符合这些特征的IT服务都可以成为云计算服务。&lt;br /&gt;
——Security Guidance for Critical Areas of Focus In Cloud Computing V3.0”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NIST(U.S. National Institute of Standards and Technology)提出了一个定义云计算的标准“NIST Working Definition of Cloud Computing/NIST 800-145”，这个标准中提出云计算具备的五个基本要素：&lt;strong&gt;通过网络分发服务、自助服务、可衡量的服务、资源的灵活调度、资源池化&lt;/strong&gt;。另外，这个标准还提到，云计算按照服务类型可以分为 &lt;strong&gt;IaaS、PaaS、SaaS&lt;/strong&gt; 三类，按照部署模式分为 &lt;strong&gt;公有云、私有云、混合云和社区云&lt;/strong&gt; 四种。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiweiyin318.github.io/images/IaaS-PaaS-SaaS.PNG&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iaas-infrastructure-as-a-service&#34;&gt;IaaS (Infrastructure as a service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Infrastructure as a service (IaaS)  is a cloud computing offering in which a vendor provides users access to computing resources such as servers, storage and networking. Organizations use their own platforms and applications within a service provider’s infrastructure.&lt;br /&gt;
Examples: DigitalOcean, Linode, Rackspace, Amazon Web Services (AWS), Microsoft Azure, Google Compute Engine (GCE), 阿里云，腾讯云&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;IaaS 要解决什么问题？&lt;br /&gt;
1. 用户不用购买硬件设备了，直接按需购买资源就行了。&lt;br /&gt;
2. 用户可以按需扩容缩容自己所需要的资源。 (业务忙时多申请几个机子，业务不忙了少几个机子，反正时按资源收费的。)&lt;br /&gt;
3. 不用安排专人维护硬件设备了，也不会有什么机房断电，设备单点故障了影响业务。&lt;br /&gt;
4. 用起来让你感觉跟物理机没啥区别。&lt;/p&gt;

&lt;h3 id=&#34;paas-platform-as-a-service&#34;&gt;PaaS (Platform as a Service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Platform as a service (PaaS) is a cloud computing offering that provides users with a cloud environment in which they can develop, manage and deliver applications. In addition to storage and other computing resources, users are able to use a suite of prebuilt tools to develop, customize and test their own applications.&lt;br /&gt;
Examples: AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine, Apache Stratos, OpenShift&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PaaS 要解决什么问题？&lt;br /&gt;
云上有了资源（虚拟机）后，提供给用户一套开发，测试，打包，发布，管理和运维的平台，让你很方便的在IaaS上搞你的业务，不用care底层资源 。&lt;/p&gt;

&lt;h3 id=&#34;saas-software-as-a-service&#34;&gt;SaaS (Software as a Service)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Software as a service (SaaS)  is a cloud computing offering that provides users with access to a vendor’s cloud-based software. Users do not install applications on their local devices. Instead, the applications reside on a remote cloud network accessed through the web or an API. Through the application, users can store and analyze data and collaborate on projects.&lt;br /&gt;
Examples: Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SaaS 要解决什么问题？&lt;br /&gt;
这个我也没接触过，理解就是所有软件都在云上了，你只要类似打开浏览器的东东就可以用各种软件，不用再安装了，你的数据啥的都在云上了。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考:&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/cloud/learn/iaas-paas-saas&#34;&gt;https://www.ibm.com/cloud/learn/iaas-paas-saas&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.computenext.com/blog/when-to-use-saas-paas-and-iaas/&#34;&gt;https://www.computenext.com/blog/when-to-use-saas-paas-and-iaas/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Platform_as_a_service&#34;&gt;https://en.wikipedia.org/wiki/Platform_as_a_service&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&#34;&gt;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;历史&#34;&gt;历史&lt;/h1&gt;

&lt;h2 id=&#34;docker-的出现&#34;&gt;Docker 的出现&lt;/h2&gt;

&lt;p&gt;2013年那会云计算不再时虚无缥缈的概念了，已经商业化比较成熟了，AWS如日中天，Openstack火的一塌糊涂，以Cloud Foundry为代表的开源PaaS项目度过了最艰难的的概念普及和用户教育阶段，吸引力一堆知名技术厂商的投入，开始了以开源PaaS为核心构建平台层服务能力的变革，PaaS的时代来临了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Cloud Foundry is an open source, multi cloud application platform as a service (PaaS) governed by the Cloud Foundry Foundation, a 501&amp;copy;(6) organization.The software was originally developed by VMware and then transferred to Pivotal Software, a joint venture by EMC, VMware and General Electric.&lt;br /&gt;
&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Cloud_Foundry&#34;&gt;https://en.wikipedia.org/wiki/Cloud_Foundry&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker公司那会还叫dotCloud也是PaaS热潮的中一个小公司，主打产品与主流的Cloud Foundry社区脱节，长期无人问津。&lt;br /&gt;
* 2013年3月，dotCloud公司推出自己的容器开源项目Docker。&lt;br /&gt;
* 2013年10月，dotCloud公司正式转换业务核心并将自身重新定名为Docker。到这时，Docker已经拥有超过200名贡献者，其中九成以上来自公司之外。Docker的下载量超过10万次，包括eBay在内的众多企业开始对其加以利用，相关社区也在全球范围内快速建立。短短几个月Cloud Foundry和其他PaaS社区还没来得及成为它的对手就已经出局了。  dotCloud公司改名为Docker公司。&lt;/p&gt;

&lt;h2 id=&#34;遇到和解决了什么问题&#34;&gt;遇到和解决了什么问题&lt;/h2&gt;

&lt;h3 id=&#34;cloud-foundry的paas解决了什么问题&#34;&gt;Cloud Foundry的PaaS解决了什么问题&lt;/h3&gt;

&lt;p&gt;当时大家租赁AWS或者Openstack的虚机机，还是像以前管理物理机那样，通过脚本或者手动的方式在虚拟机上部署应用。但是云上的资源环境和物理机还是不一致的，当时的云计算服务比的是谁能更好的模拟本地服务器环境，能带来更好的“云上”体验。&lt;/p&gt;

&lt;p&gt;PaaS的出现就是解决这个问题的一个最佳方案。举个例子，虚拟机建好后，运维人员只需在这些机子上部署一个Cloud Foundry项目，然后执行一条命令就可以把本地的应用部署到云上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cf push &amp;#34;我的应用&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Cloud Foundry这样的PaaS项目最核心的组件就是打包和分发机制。为每种语言都定义一种打包机制，push时相当于把可执行文件和启动脚本打包到一个压缩包里面，上传到云上的存储种，然后调度一个可用的虚机，这个虚机的agent下载应用启动运行。&lt;/p&gt;

&lt;p&gt;由于同一个虚机会运行不同的应用，Cloud Foundry调用系统的Cgroups和Namespace机制为每一个应用单独创建一个叫“沙盒”的隔离环境，在“沙盒”里启动这些应用进程，实现一个虚机里面同时运行不同的应用，互不干涉。沙盒也就是后来的容器。&lt;/p&gt;

&lt;h3 id=&#34;docker解决了什么问题&#34;&gt;Docker解决了什么问题&lt;/h3&gt;

&lt;p&gt;Docker发布后，技术上跟Cloud Foundry的沙盒没有啥本质区别，但是最大不同就是容器的镜像。&lt;/p&gt;

&lt;p&gt;问题出在Cloud Foundry的一键部署很方便，但是打包却比较麻烦，一旦用上PaaS，用户必须为每一种语言，框架，甚至版本维护一给打好的包，而这个打包过程，除了可执行文件和启动脚本外，需要修改好多配置才能跑起来，这个修改没有经验可用借鉴，全凭试错尝试。&lt;/p&gt;

&lt;p&gt;Docker 镜像恰巧解决了这个问题。这个镜像就是一个压缩包，直接由一整套完整的操作系统的文件和目录组成的，有应用所需要的完整的依赖环境，内容可用和测试环境完全一样，所有不需要任何配置和修改直接保证了本地环境和云端环境的高读一致。拿着这个压缩包，使用某种技术创建一个“沙盒”环境，在沙盒里面解压缩，运行程序就可以了。&lt;strong&gt;这就是Docker的精髓。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PaaS最核心的打包系统一下子无用武之地了，抓狂的打包过程消失了。&lt;/p&gt;

&lt;p&gt;提供一个下载好的操作系统文件和目录，制作一个压缩包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;docker build &amp;#34;镜像&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Docker创建一个“沙盒”，解压压缩包，运行自己的应用。这个沙盒也是通过Cgroups和Namespace技术来实现环境隔离的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;docker run &amp;#34;镜像&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;docker公司是怎么把docker搞火的&#34;&gt;Docker公司是怎么把Docker搞火的&lt;/h3&gt;

&lt;p&gt;Docker公司的重要战略是“坚持把开发者群体放在至高无上的位置”，所以一开始Docker的推广是以开发者为主导的，简单的UI，有趣的demo，无论是你懂不懂后端，很简单就可以发布自己的应用，PaaS的受益者和最终用户，肯定都是开发者。&lt;br /&gt;
Docker只是个开源项目的名称，dotCloud公司将自己的公司名字改为了Docker，鲸鱼的Logo也成为了商业商标。&lt;/p&gt;

&lt;h3 id=&#34;docker为啥发布swarm项目&#34;&gt;Docker为啥发布Swarm项目&lt;/h3&gt;

&lt;p&gt;Docker项目的出现，让PaaS的定义由之前的CLoud Foundry描述的那样变成了一个由Docker镜像为标准的全新的概念。&lt;/p&gt;

&lt;p&gt;Docker虽然解决了打包的问题，还不能叫做PaaS，因为PaaS的另一个重要功能是大规模部署。Docker在2014年的DockerCon上推出了自己的容器集群管理项目Swarm，预示着Docker公司想重新定义PaaS的愿望。&lt;/p&gt;

&lt;p&gt;Docker的快速崛起后，CoreOS公司快速将容器融入自己的PaaS解决方案中，是当时DOcker项目的第二重要力量，但是随着Docker公司战略和对Docker项目的定位的改变，Docker公司想提供更多平台层的能力，向PaaS项目发展。显然和CoreOS的核心产品和战略冲突，2014年底CoreOS退出Docker项目，发布了自己Rocket(rkt)容器。&lt;/p&gt;

&lt;p&gt;CoreOS是一系列开源项目的组合，包括Container Linux操作系统，Fleet作业调度工具，systemd进程管理，rkt容器。Swarm则是以一个完整的整体来对外管理集群，最大亮点是完全使用Docker项目的API来完成管理集群，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#单机Docker项目：
docker run “我的镜像”

#集群Docker项目：
docker run -H “Swarm集群IP” “我的镜像”&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;编排概念的出现&#34;&gt;编排概念的出现&lt;/h3&gt;

&lt;p&gt;Docker的崛起，2014-2015年催生了一个繁荣的Docker生态，Docker收购了Fig项目，后面改名为Compose项目。&lt;/p&gt;

&lt;p&gt;编排在云计算领域是指通过工具或者配置来完成一组虚拟机以及相关资源的定义，配置，创建，删除等工作。&lt;/p&gt;

&lt;p&gt;Fig项目首次提出了容器编排概念“Container Orchestration”。通过执行一条简单命令，将一个配置文件里面定义的不同的容器，按照他们的指定关联关系创建起来。&lt;/p&gt;

&lt;h3 id=&#34;mesos的转型&#34;&gt;Mesos的转型&lt;/h3&gt;

&lt;p&gt;Mesos昨晚Berkeley主导的大数据套件之一，是当时大数据最受欢迎的资源管理项目，跟Yarn项目杀的难舍难分。大数据项目关注的是计算密集型离线业务，对应用打包和集群扩容托管没啥强烈需求，Hadoop，Spark等项目到现在也没有在容器上投入更大赌注。&lt;/p&gt;

&lt;p&gt;Mesos的两层调度系统，天然可以支持PaaS业务，Mesos+Marathon项目很快成了Docker Swarm的有力竞争对手。Mesos拥有超大规模集群管理的经验，也有大规模生产环境在使用了，比如eBa，。Marathon提供了应用托管和负载均功能。Mesos公司提出了DC/OS的口号和产品，旨在使用户能够像管理一台机器一样管理一个万级别的物理集群，并且使用Docker容器在这个集群中自由部署应用。&lt;/p&gt;

&lt;h3 id=&#34;kubernetes的诞生&#34;&gt;Kubernetes的诞生&lt;/h3&gt;

&lt;p&gt;这个时候CoreOS完全被Docker压制，RedHat作为Docker项目早期重要贡献者也因为Docker公司的平台战略不满退出，OpenSift还勉强支撑，Mesos和Swarm是主要竞争对手。2014年6月Google发力，发布了Kubernetes项目，这个项目不仅挽救了CoreOS和RedHat，同时改变了整个容器市场的格局。&lt;/p&gt;

&lt;p&gt;2014-2015年，整个容器社区热闹非凡，大量围绕Docker项目的网络，存储，监控，CI/CD，UI项目纷纷出台，也涌现出了Rancher，Tutun开源和商业上都取得成功的创业公司。Docker公司发布了Compose，Swarm和Machine三件套，Docker公司想从开源成功走向商业成功。&lt;/p&gt;

&lt;p&gt;Google的容器项目也招架住Docker，Google本想提议关停自己容器项目，和Docker共同推出了一个中立的容器运行时库（container runtime）作为Docker项目的核心依赖。DOcker没有同意削弱自己地位的建议，推出了自己的容器运行时库Libcontainer。由于比较匆忙，代码可读性差，可维护不强，被社区长期诟病。&lt;/p&gt;

&lt;p&gt;2015年6月，各个玩家开始切割Docker项目的话语权，手段也很经典。由Docker牵头，CoreOS，Google，RedHat等公司宣布，Docker将LibContainer捐出，改名RunC项目，交由一个完全中立的基金会管理，然后以RunC为依据，共同指定一套容器和镜像的标准和规范。&lt;/p&gt;

&lt;p&gt;这套标准规范就是OCI （open Container Initiative）。提出将容器运行和镜像的实现从Dokcer项目完全剥离出来，一方面改善了Docker在这一块一家独大的现状，另一方面各个玩家可以不依赖Docker项目构建各自的平台能力。这是一群玩家根据各自利益干涉的一个妥协结果。Docker公司虽然时OCI的发起者和创始成员，但是很少在标准指定上扮演关键角色，也没有动力去推进这些所谓的标准，这就是为啥OCI组织效率持续低下的根本原因。&lt;/p&gt;

&lt;p&gt;Docker不担心OCI的威胁，是因为Docker项目的容器生态的事实标准，社区足够庞大。但是斗争转移到容器之上的平台层，即PaaS，Docker公司就没有多大优势了。这个领域Google和RedHat有着深厚的技术积累，CoreOS这样的创业公司也有像Etcd这样的开源基础设施项目，Docker只有一个Swarm。&lt;/p&gt;

&lt;p&gt;Google，RedHat等开源基础设施玩家，共同牵头发起了一个CNCF（Cloud Native Computing Foundation）的基金会。目的就是希望以Kubernetes项目为基础，建立一个由开源基础设施厂商主导的，按照独立基金会运行的平台级社区，对抗Docker公司为核心的容器商业生态。&lt;/p&gt;

&lt;p&gt;Kubernetes的竞争对手为Swarm和Mesos，Swarm擅长和Docker生态无缝集成，Mesos擅长大规模集群的调度和管理。Kubernetes另开辟径，将Borg和Omega系统的内部特性落到Kubernetes项目上，就是Pod，Sidecar等超前的功能和设计模式。这些都是Google公司在这个领域多年的经验积累沉淀。RedHat和Google达成联盟，为这个项目投入了很多贡献，保证了自己的影响力。&lt;/p&gt;

&lt;p&gt;Mesos的Apache社区比较封闭，虽然成熟，但是缺乏创新，Swarm虽然强调Docker Native，但是杀伤力不大。Kubernetes项目耳目一新的设计理念和号召力，构建出了一个与众不同的容器编排和管理生态，迅速崛起，Github社区各项指标一骑绝尘，Swarm远远被甩身后。&lt;/p&gt;

&lt;p&gt;CNCF社区添加了像Prometheus，Fluentd，CNI等一系列容器知名生态工具和项目，大量的公司和创业团队开始专门针对CNCF社区而非Docker公司制定推广策略。&lt;/p&gt;

&lt;p&gt;Docker为了应对竞争，2016年宣布放弃Swarm项目，将容器编排和集群管理功能内置到Docker项目中，虽然可以使得Docker项目的边界扩大到一个完整的PaaS项目范畴，但是增加了技术复杂度和维护难度。&lt;/p&gt;

&lt;p&gt;Kubernetes反其道行之，在社区推进“民主化”架构，从API到容器运行时的每一层，都为开发者提供可扩展的插件机制，鼓励通过代码方式介入到Kubernetes的每一个阶段。催生了大量基于Kubernetes API和扩展接口的二次创业工作，社区在2016年之后得到了空前的发展。不同于之前局限于打包发布的PaaS化路线，这一次是围绕Kubernetes项目为核心的百花争鸣。Docker公司不得不面对这次豪赌的失败，开始放弃开源社区，专注于自己的商业化转型。&lt;/p&gt;

&lt;p&gt;2017年开始，Docker公司将DOcker项目的容器运行时部分Containerd捐赠给了CNCF社区，标志着Docker项目完全升级为一个PaaS平台，Docker宣布将Docker项目改名为Moby，交给社区自行维护。&lt;/p&gt;

&lt;p&gt;2017年10月，Docker宣布在自己主打产品Docker企业版内置Kubernetes项目。&lt;/p&gt;

&lt;p&gt;2018年1月20日，RedHat收购CoreOS。&lt;/p&gt;

&lt;p&gt;2018年3月28日，Docker公司的CTO Solomon Hykes 宣布辞职。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;后面这段历史原作者将的酣畅淋漓，基本照搬过来的。大家自行体会这几年这个领域的风云变化和各大玩家的角逐。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>golang rand生成随机数</title>
      <link>https://zhiweiyin318.github.io/post/golang-rand%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/golang-rand%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      
        <description>

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;math/rand package实现了伪随机数字生成器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;随机数字是通过Source生成的，rand.Seed会初始化默认全局的Source，如果不调用rand.Seed就会使用默认的Source。所生成的随机数字是固定顺序生成的，每次运行程序如果seed相同的话，生成随机数是相同的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;默认的Source是线程安全的，自己通过New生成的不是。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;参考： &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34;&gt;https://golang.org/pkg/math/rand/&lt;/a&gt;&lt;br /&gt;
Package rand implements pseudo-random number generators.&lt;/p&gt;

&lt;p&gt;Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;源码：&lt;a href=&#34;https://github.com/zhiweiyin318/yzw.go.demo/tree/master/rand&#34;&gt;https://github.com/zhiweiyin318/yzw.go.demo/tree/master/rand&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;rand1 使用默认的Seed和Source，每次执行main，获取的随机数字都是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand1() {
	fmt.Println(&amp;#34;rand1 test ######## rand.xx ######## &amp;#34;)
	fmt.Println(&amp;#34;rand int : &amp;#34;, rand.Int(), rand.Int31())
	// random int in [0,100)
	fmt.Println(&amp;#34;random int in [0,100) : &amp;#34;, rand.Intn(100))
	// random int in [-50,50)
	fmt.Println(&amp;#34;random int in [-50,50) : &amp;#34;, rand.Intn(100)-50)
	fmt.Println(&amp;#34;rand float : &amp;#34;, rand.Float64())
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand2 每次配置相同的Seed，则生成的随机值都是相同的。下面循环5次的随机数字都是一样的，因为Seed重装了Source，都是从头开始生成随机数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand2() {
	fmt.Println(&amp;#34;rand2 test ######## generate the same random values using the same rand.Seed  ######## &amp;#34;)
	for i := 0; i &amp;lt; 5; i++ {
		rand.Seed(10)
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand3 配置不同的Seed，生成的随机值是不同的。但是同一个Seed在执行main后生成的值都是相同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand3(){
	fmt.Println(&amp;#34;rand2 test ######## generate the same random values using the different rand.Seed  ######## &amp;#34;)
	for i := 0; i &amp;lt; 5; i++ {
		rand.Seed((int64)(i))
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand4 使用rand.New()生成新的rand，rand.NewSource()生成新的Source。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand4() {
	fmt.Println(&amp;#34;rand4 test ######## rand.NewSource and rand.New ######## &amp;#34;)
	s := rand.New(rand.NewSource(1))
	for i := 0; i &amp;lt; 5; i++ {
		fmt.Println(&amp;#34;rand4: &amp;#34;, s.Int(), s.Intn(20), s.Float64())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand5 保证每次运行程序随机值跟上次不一样，可以通过当前实际生成Seed&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func rand5(){
	fmt.Println(&amp;#34;rand4 test ######## use time.Now().Unix() as seed ######## &amp;#34;)
	rand.Seed(time.Now().Unix())
	for i := 0; i &amp;lt; 5; i++ {
		fmt.Println(&amp;#34;rand seed 10 int : &amp;#34;, rand.Int(), rand.Int31())
	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rand6 协程安全测试&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;待补充...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>golang的测试框架</title>
      <link>https://zhiweiyin318.github.io/post/golang%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/golang%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      
        <description>

&lt;h1 id=&#34;golang-测试框架&#34;&gt;golang 测试框架&lt;/h1&gt;

&lt;p&gt;本文主要介绍golang 测试的集中常见的框架。&lt;/p&gt;

&lt;h2 id=&#34;go-test&#34;&gt;go test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件名称位xx_test.go&lt;/li&gt;
&lt;li&gt;测试函数Testxxx(t *testing.T)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go test -v&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;goconvey&#34;&gt;GoConvey&lt;/h2&gt;

&lt;p&gt;可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性，集成go test。&lt;/p&gt;

&lt;p&gt;Write behavioral tests in your editor. Get live results in your browser.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/smartystreets/goconvey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;官网：&lt;code&gt;http://goconvey.co/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;介绍：&lt;code&gt;https://www.jianshu.com/p/e3b2b1194830&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/smartystreets/goconvey &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在$GOPATH/src目录下新增了github.com子目录，该子目录里包含了GoConvey框架的库代码&lt;/li&gt;
&lt;li&gt;在$GOPATH/bin目录下新增了GoConvey框架的可执行程序goconvey&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;web显示结果，在测试目录下执行goconvoy就可以&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;testing&amp;#34;
)

func Test_ServerRun(t *testing.T) {
    Convey(&amp;#34;Test ServerRun &amp;#34;, t, func() {
        Convey(&amp;#34;Case 1 port &amp;gt; 10000:&amp;#34;, func(){
            port := 100000
            So(ServerRun(port), ShouldBeError)
        })
        Convey(&amp;#34;Case 2 port &amp;lt;= 10000:&amp;#34;, func() {
            port := 1000
            So(ServerRun(port), ShouldBeNil)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;gostub&#34;&gt;GoStub&lt;/h2&gt;

&lt;p&gt;主要用来给全局变量打桩，也可以给函数打桩，无法给方法接口打桩。
* 项目：&lt;code&gt;https://github.com/prashantv/gostub&lt;/code&gt;
* 介绍：&lt;code&gt;https://www.jianshu.com/p/70a93a9ed186&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;安装-1&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/prashantv/gostub&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-1&#34;&gt;使用&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    &amp;#34;testing&amp;#34;
    . &amp;#34;github.com/prashantv/gostub&amp;#34;
)
func Test_ServerRun_Case3(t *testing.T){
    Convey(&amp;#34;Test ServerRun &amp;#34;,t,func(){
        Convey(&amp;#34;Case 1 IP is not local IP:&amp;#34;,func(){
            stubs :=Stub(&amp;amp;localIP,&amp;#34;192.168.1.1&amp;#34;)
            defer stubs.Reset()
            So(ServerRun(8080), ShouldBeError)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;monkey&#34;&gt;Monkey&lt;/h2&gt;

&lt;p&gt;可以给函数，方法打桩&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/bouk/monkey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;官网：&lt;code&gt;https://bou.ke/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;介绍：&lt;code&gt;https://www.jianshu.com/p/2f675d5e334e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装-2&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;go get github.com/bouk/monkey&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-2&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;inline 函数打桩无效&lt;/li&gt;
&lt;li&gt;方法的首字母大小写，只能给首大写字母的方法打桩&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    &amp;#34;github.com/bouk/monkey&amp;#34;
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;reflect&amp;#34;
    &amp;#34;testing&amp;#34;
    &amp;#34;errors&amp;#34;
)
func Test_ServerRun_Monkey(t *testing.T) {
    Convey(&amp;#34;Test ServerRun &amp;#34;, t, func() {
        Convey(&amp;#34;Case 1 Listen failed:&amp;#34;, func() {
            defer monkey.UnpatchAll()
            monkey.Patch(Listen, func(s *server) error {
                return errors.New(&amp;#34;fake return fail&amp;#34;)
            })
            So(ServerRun(8080), ShouldBeError)
        })

        Convey(&amp;#34;Case 2 s.GetIP failed:&amp;#34;, func() {
            var s *server
            defer monkey.UnpatchAll()
            monkey.PatchInstanceMethod(reflect.TypeOf(s), &amp;#34;GetIP&amp;#34;, func(_ *server) string {
                return &amp;#34;192.168.1.1&amp;#34;
            })
            So(ServerRun(8080),ShouldBeError)
        })
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;gomock&#34;&gt;GoMock&lt;/h2&gt;

&lt;p&gt;给接口打桩&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目：&lt;code&gt;https://github.com/golang/mock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文档：&lt;code&gt;https://godoc.org/github.com/golang/mock/gomock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参考：&lt;code&gt;https://www.jianshu.com/p/f4e773a1b11f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装-3&#34;&gt;安装&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;mkdir $GOPATH/src/golang.org/x/
cd $GOPATH/src/golang.org/x/
git clone https://github.com/golang/net.git net 
go install net
go get github.com/golang/mock/gomock
go install github.com/golang/mock/mockgen&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;使用-3&#34;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;生成接口的mock文件&lt;/li&gt;
&lt;li&gt;输出目录需要提起建好&lt;/li&gt;
&lt;li&gt;gomock的代码需放在$GOPATH/src下，mockgen运行时要在这个路径下访问gomock&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-command&#34; data-lang=&#34;command&#34;&gt;./mockgen -source=/home/yzw/go/src/examples/pkg/common/common.go &amp;gt; /home/yzw/go/src/examples/test/common/mock_common.go&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;import (
    . &amp;#34;github.com/golang/mock/gomock&amp;#34;
    . &amp;#34;github.com/smartystreets/goconvey/convey&amp;#34;
    &amp;#34;testing&amp;#34;

    &amp;#34;examples/test/common&amp;#34;
    &amp;#34;errors&amp;#34;
    &amp;#34;github.com/bouk/monkey&amp;#34;
    &amp;#34;examples/pkg/common&amp;#34;
    &amp;#34;fmt&amp;#34;
)

func Test_ClientRun_GoMock(t *testing.T) {
    Convey(&amp;#34;Test ClientRun&amp;#34;, t, func() {
        ctrl := NewController(t)
        defer ctrl.Finish()
        mockOpter := mock_common.NewMockOpter(ctrl)
        mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))

        defer monkey.UnpatchAll()
        monkey.Patch(NewClient, func() common.Opter {
            fmt.Println(&amp;#34;fake newclient&amp;#34;)
            return mockOpter
        })
        So(ClientRun(&amp;#34;ip&amp;#34;,&amp;#34;port&amp;#34;,&amp;#34;opt&amp;#34;),ShouldBeError)
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果mock的接口被调用多次，需要用Times&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;)).Times(5)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;mock的接口有先后顺序的时候，需要同After，InOder来保序&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;getCall := mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))
mockOpter.EXPECT().Post(Any()).Return(errors.New(&amp;#34;mock post error&amp;#34;)).After(getCall)
InOder(
    mockOpter.EXPECT().Get(Any()).Return(&amp;#34;mock get data&amp;#34;, errors.New(&amp;#34;mock get error&amp;#34;))
    mockOpter.EXPECT().Post(Any()).Return(errors.New(&amp;#34;mock post error&amp;#34;))
)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Start</title>
      <link>https://zhiweiyin318.github.io/post/start/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zhiweiyin318.github.io/post/start/</guid>
      
        <description>

&lt;h2 id=&#34;为啥搞blog&#34;&gt;为啥搞blog&lt;/h2&gt;

&lt;p&gt;之前在sina写过复盘日记，后来也没坚持下来；之前在github上用其他框架搭过blog，太繁琐了，也放弃了。&lt;/p&gt;

&lt;p&gt;最近在有道云上记笔记，开始用markdown，觉得很方便，正好看到Hugo这个go写的静态网页框架，天然对go的好感，索性就搞一把。&lt;/p&gt;

&lt;p&gt;以后把笔记就记这了，走哪都方便查看。&lt;/p&gt;

&lt;h2 id=&#34;怎么用hugo-github搭建blog&#34;&gt;怎么用hugo+github搭建blog&lt;/h2&gt;

&lt;h3 id=&#34;下载hugo可执行文件-二进制文件&#34;&gt;下载hugo可执行文件（二进制文件）&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;下载地址： &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;https://github.com/gohugoio/hugo/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;创建框架&#34;&gt;创建框架&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; ./hugo.exe new site blog     &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;下载更换主题&#34;&gt;下载更换主题&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;cd blog
git clone https://github.com/xianmin/hugo-theme-jane.git themes/jane&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;主题下载地址：&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;修改主题&#34;&gt;修改主题&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; cp themes/jane/exampleSite/config.toml ./&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;特别是config.toml文件&lt;/p&gt;

&lt;h3 id=&#34;新建博文&#34;&gt;新建博文&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe new start.md&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;本地测试&#34;&gt;本地测试&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe server&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 可以查看效果&lt;/p&gt;

&lt;h3 id=&#34;发布&#34;&gt;发布&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;../hugo.exe&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;生成public文件夹，将该文件夹所有文件push到username.github.io仓库。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我之前以为要把整个目录上传，发现不现实，最后才搞明白是把public上传就可以了，但是每次生成发布比较麻烦，准备搞个脚本弄哈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;issue&#34;&gt;issue&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;怎么贴图&lt;br /&gt;
图片放到/static下，md里里面直接引用相对路径，比如我把图片放到static/images下了，直接引用/images/xxx就可以了。发布的时候会拷贝过去。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nanshu.wang/post/2015-01-31/&#34;&gt;http://nanshu.wang/post/2015-01-31/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&#34;&gt;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
  </channel>
</rss>